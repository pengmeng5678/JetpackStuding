https://github.com/android/architecture-components-samples
一.架构组件
    1.Lifecycle
    2.LiveData
        1.在Activity中监听LiveData的变化后，会回调onChange方法
            MutableLiveData<String> mutableLiveData  = new MutableLiveData<>();
            mutableLiveData.observe(this, new Observer<String>() {//1
                @Override
                public void onChanged(@Nullable final String s) {
                    Log.d(TAG, "onChanged:"+s);
                }
            });
        2.一般在ViewModel层更新数据
            mutableLiveData.postValue("Android进阶三部曲");//setValue只能在主线程中使用
        3.更改LiveData的数据,Transformations
            如果我们想在LiveData对象分发给观察者之前对其中存储的值进行更改，可以使用Transformations.map和Transformations.switchMap()
            MutableLiveData<String> mutableLiveData  = new MutableLiveData<>();
            mutableLiveData.observe(this, new Observer<String>() {
                @Override
                public void onChanged(@Nullable final String s) {
                    Log.d(TAG, "onChanged1:"+s);
                }
            });
            LiveData transformedLiveData =Transformations.map(mutableLiveData, new Function<String, Object>() {
                @Override
                public Object apply(String name) {
                   return name + "+Android进阶解密";
                }
            });
            transformedLiveData.observe(this, new Observer<String>() {
                @Override
                public void onChanged(@Nullable final String s) {
                    Log.d(TAG, "onChanged2:"+s);
                }
            });
            mutableLiveData.postValue("Android进阶之光");
            打印结果：
                onChanged1:Android进阶之光
                onChanged2:Android进阶解密
        4.监听某个数据的变化，且能随时切换监听，可以使用Transformations.switchMap()
            LiveData transformedLiveData= Transformations.switchMap(liveDataSwitch, new Function<Boolean, LiveData<String>>() {
                @Override
                public LiveData<String> apply(Boolean input) {
                    if (input) {
                        return mutableLiveData1;
                    } else {
                        return mutableLiveData2;
                   }
                }
            });

            transformedLiveData.observe(this, new Observer<String>() {
                @Override
                public void onChanged(@Nullable final String s) {
                    Log.d(TAG, "onChanged:" + s);
                }
            });
            liveDataSwitch.postValue(false);//2
            mutableLiveData1.postValue("Android进阶之光");
            mutableLiveData2.postValue("Android进阶解密");

        5.合并多个MutableLiveData,使用MediatorLiveData.addSource，将多个MutableLiveData合并到一起，
        这样当任何一个MutableLiveData数据发生变化时,MediatorLiveData都能感知到

    3.ViewModel
        1.自定义ViewModel
           public class MyViewModel extends ViewModel {
               private MutableLiveData<String> name;
               public LiveData<String> getName() {
                   if (name == null) {
                       name = new MutableLiveData<String>();
                       addName();
                   }
                   return name;
               }
               private void addName() {
                   name.setValue("Android进阶解密");
               }
           }
      2.使用ViewModel
            Activity中简单初始化
                MyViewModel model = ViewModelProviders.of(this).get(ViewModel.class);
                model.getName().observe(this,new Observer<String>{
                    @Override
                    public void onChange(@Nullable String s){
                        Log.d(TAG, "畅销书："+s);
                    }
                })
            另一种初始化方式(自定义Factory,为ViewModel注入数据仓库等对象)
                ProductViewModel.Factory factory = new ProductViewModel.Factory(
                        requireActivity().getApplication(), getArguments().getInt(KEY_PRODUCT_ID));

                final ProductViewModel model = new ViewModelProvider(this, factory)
                        .get(ProductViewModel.class);

                这里创建ProductViewModel的时候,在Factory中就会注入productId,Respository等数据,Factory类如下所示
                public static class Factory extends ViewModelProvider.NewInstanceFactory {
                    ...
                    private final DataRepository mRepository;
                    public Factory(@NonNull Application application, int productId) {
                        mApplication = application;
                        mProductId = productId;
                        mRepository = ((BasicApp) application).getRepository();
                    }

                    @Override
                    public <T extends ViewModel> T create(Class<T> modelClass) {
                        //noinspection unchecked
                        return (T) new ProductViewModel(mApplication, mRepository, mProductId);
                    }
                }
            Kotlin初始化ViewModel(自定义Factory)
                private val viewmodel:MyViewModel by viewModels {ViewModelProvider.Factory实现类}
                其中ViewModelProvider.Factory实现类会为MyViewModel的构造函数注入其所需的数据库对象等
    4.Room
        1.创建实体类并添加相应注解
            @Entity(tableName = "products")
            public class ProductEntity implements Product {
                @PrimaryKey
                private int id;
                ...
            }
            如果有多表级联时，子表要绑定外键
                @Entity(tableName = "comments",
                        foreignKeys = {
                                @ForeignKey(entity = ProductEntity.class,
                                        parentColumns = "id",
                                        childColumns = "productId",
                                        onDelete = ForeignKey.CASCADE)},
                        indices = {@Index(value = "productId")
                        })
                public class CommentEntity implements Comment {
                    @PrimaryKey(autoGenerate = true)
                    private int id;
                    private int productId;
                        ...
                }

        2.创建抽象类AppDatabase继承RoomDatabase
            @Database(entities = {ProductEntity.class, ProductFtsEntity.class, CommentEntity.class}, version = 2)
            @TypeConverters(DateConverter.class)
            public abstract class AppDatabase extends RoomDatabase {
                private static AppDatabase sInstance;
                @VisibleForTesting
                public static final String DATABASE_NAME = "basic-sample-db";

                public abstract ProductDao productDao();
                public abstract CommentDao commentDao();
            }
        3.在AppDatabase中初始化表
            private static AppDatabase buildDatabase(final Context appContext,
                    final AppExecutors executors) {
                return Room.databaseBuilder(appContext, AppDatabase.class, DATABASE_NAME)
                        .addCallback(new Callback() {
                            @Override
                            public void onCreate(@NonNull SupportSQLiteDatabase db) {
                                super.onCreate(db);
                                executors.diskIO().execute(() -> {
                                    // Add a delay to simulate a long-running operation
                                    addDelay();
                                    // Generate the data for pre-population
                                    AppDatabase database = AppDatabase.getInstance(appContext, executors);
                                    List<ProductEntity> products = DataGenerator.generateProducts();
                                    List<CommentEntity> comments =
                                            DataGenerator.generateCommentsForProducts(products);

                                    insertData(database, products, comments);
                                    // notify that the database was created and it's ready to be used
                                    database.setDatabaseCreated();
                                });
                            }
                        })
                    .addMigrations(MIGRATION_1_2)
                    .build();

        4.创建Dao查询接口
           @Dao
           public interface CommentDao {
               @Query("SELECT * FROM comments where productId = :productId")
               LiveData<List<CommentEntity>> loadComments(int productId);

               @Query("SELECT * FROM comments where productId = :productId")
               List<CommentEntity> loadCommentsSync(int productId);

               @Insert(onConflict = OnConflictStrategy.REPLACE)
               void insertAll(List<CommentEntity> comments);
           }

           @Dao
           public interface ProductDao {
               @Query("SELECT * FROM products")
               LiveData<List<ProductEntity>> loadAllProducts();

               @Insert(onConflict = OnConflictStrategy.REPLACE)
               void insertAll(List<ProductEntity> products);

               @Query("select * from products where id = :productId")
               LiveData<ProductEntity> loadProduct(int productId);

               @Query("select * from products where id = :productId")
               ProductEntity loadProductSync(int productId);

               @Query("SELECT products.* FROM products JOIN productsFts ON (products.id = productsFts.rowid) "
                   + "WHERE productsFts MATCH :query")
               LiveData<List<ProductEntity>> searchAllProducts(String query);
           }

        5.创建数据库仓库实现接口，供用户使用
           public class DataRepository {
               private static DataRepository sInstance;
               ...
               public LiveData<List<ProductEntity>> getProducts() {
                   return mObservableProducts;
               }

               public LiveData<ProductEntity> loadProduct(final int productId) {
                   return mDatabase.productDao().loadProduct(productId);
               }

               public LiveData<List<CommentEntity>> loadComments(final int productId) {
                   return mDatabase.commentDao().loadComments(productId);
               }

               public LiveData<List<ProductEntity>> searchProducts(String query) {
                   return mDatabase.productDao().searchAllProducts(query);
               }
           }
    5.Navigation
        https://developer.android.google.cn/guide/navigation/navigation-getting-started
        使用前添加依赖
            dependencies {
              def nav_version = "2.1.0"

              // Java
              implementation "androidx.navigation:navigation-fragment:$nav_version"
              implementation "androidx.navigation:navigation-ui:$nav_version"

              // Kotlin
              implementation "androidx.navigation:navigation-fragment-ktx:$nav_version"
              implementation "androidx.navigation:navigation-ui-ktx:$nav_version"

            }
        1布局文件里面声明导航文件navigation.xml,navigation.xml在
            <fragment
                 android:id="@+id/my_nav_host_fragment"
                 ...
                 android:name="androidx.navigation.fragment.NavHostFragment"
                 app:defaultNavHost="true"
                 app:navGraph="@navigation/navigation"/>
        2.navigation.xml文件中写导航的action
            1.初始的Fragment在TitleScreen,定义一个id为action_title_screen_to_register的action,
            2.在TitleScreen就可以通过代码跳转到id为Register的Fragment中了
            3.具体跳转逻辑Navigation.findNavController(view).navigate(R.id.action_title_screen_to_register)

               <navigation xmlns:android="http://schemas.android.com/apk/res/android"
                           xmlns:app="http://schemas.android.com/apk/res-auto"
                           xmlns:tools="http://schemas.android.com/tools"
                           app:startDestination="@+id/title_screen">
                   <fragment
                           android:id="@+id/title_screen"
                           android:name="com.example.android.navigationsample.TitleScreen"
                           android:label="fragment_title_screen"
                           tools:layout="@layout/fragment_title_screen">
                       <action
                               android:id="@+id/action_title_screen_to_register"
                               app:destination="@id/register"
                               app:popEnterAnim="@anim/slide_in_left"
                               app:popExitAnim="@anim/slide_out_right"
                               app:enterAnim="@anim/slide_in_right"
                               app:exitAnim="@anim/slide_out_left"/>
                   </fragment>
              </navigation>
    6.DataBinding

    7.WorkManager
二.基础组件
三.行为组件
四.界面组件