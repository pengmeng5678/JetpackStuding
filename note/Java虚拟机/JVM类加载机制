http://www.cnblogs.com/aspirant/p/7200523.html
https://www.cnblogs.com/mybatis/p/9396135.html
http://liuwangshu.cn/tags/ClassLoader/
1.什么是类加载器
    负责读取Java字节代码，并转换成java.lang.Class类的一个实例
2.类加载器与类的"相同"判断
    类加载器除了用于加载类外,还可以用于确定类在java虚拟机中的唯一性
    即便是同样的字节码,被不同的类加载器加载之后所得到的类,也是不同的(类的Class对象的equals方法,isAssignableFrom,isInstance,instanceOf方法为false)
    通俗的说,要判断两个类是否相同,前提是这两个类必须被同一个类加载器加载,否则这两个类不相同
3.JVM类加载器(ClassLoader)种类
    启动类加载器，Bootstrap ClassLoader,加载jre\lib中的jar文件,或者被-Xbootclasspath参数限定的类
    扩展类加载器,Extensions ClassLoader,加载jre\lib\ext中的jar文件,或者被java.ext.dirs系统变量指定的类
    应用程序类加载器,Application ClassLoader,它负责加载系统类路径java -classpath或者-D java.class.path指定路径下的类库，通过ClassLoader.getSystemClassLoader可以获取到类加载器
    自定义类加载器,通过继承ClassLoader实现,一般是加载我们的自定义类

4.双亲委派模型
    类加载器Java类如同其它的java类一样,也是要由类加载器来加载的,除了启动类加载器,每个类都有其父类加载器(父子关系由组合类实现,不是继承关系)
    所谓双亲委派是指每次收到类加载请求时,先将请求委派给父类加载器完成(所有的加载最终都会委派到Bootstrap['bʊt'stræp] Classloader)
    如果父类加载器无法完成这个加载(该加载器的搜索范围中没有找到对应的类),子类尝试自己加载
5.类加载过程
    类加载过程分为三个步骤：加载、连接、初始化，其中连接分为验证、准备、解析三个步骤
    一个类从加载到卸载的全过程：加载、验证、准备、解析、初始化、使用、卸载七个步骤

    加载：
        根据一个类的全限定名(如com.sanbot.www.Helloworld.class)来读取此类的二进制字节流到JVM内部
        将字节流所代表的静态存储结构转换为方法区的运行时数据结构,hotspot选择将Class对象存储在方法区中
        转换为一个与目标类型对应的java.lang.Class对象
    连接
        验证
            验证阶段主要包括四个校验过程:文件格式验证、元数据验证、字节码验证和符号引用验证.保证加载到JVM中的二进制流数据符合JVM要求,不会危害JVM安全
        准备
            为类中所有的静态变量分配内存空间，并为其设置初始值(由于还没有对象,实例变量将不在此操作范围)
        解析
            将常量池中所有的符号引用转为直接引用(得到类或者字段、方法在内存中的指针或者偏移量,以便直接调用),该操作可以在初始化之后再执行
    初始化
        在连接的准备阶段,类变量已赋值过一次系统要求的初始值,而在初始化阶段,则是根据程序员自己写的逻辑初始化类变量和其他资源
        如
            public static int value1 = 5;
            public static int value2 = 6;
            static{
                value2 = 66;
            }
        在连接的准备阶段,value1和value2的初始值都为0
        在初始化阶段,value1为5,value2为66
            1.所有类变量初始化语句和静态代码块都会在编译时被前端编译器放在收集器里头，
                存放到一个特殊的方法中，这个方法就是<clinit>方法，即类/接口初始化方法，该方法只能在类加载的过程中由JVM调用；
            2.编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量
            3.如果超类还没有被初始化，那么优先对超类初始化，但在<clinit>方法内部不会显示调用超类的<clinit>方法，
                由JVM负责保证一个类的<clinit>方法执行之前，它的超类<clinit>方法已经被执行
            4.JVM必须确保一个类在初始化的过程中，如果是多线程需要同时初始化它，仅仅只能允许其中一个线程对其执行初始化操作，其余线程必须等待，
                只有在活动线程执行完对类的初始化操作之后，才会通知正在等待的其他线程。(所以可以利用静态内部类实现线程安全的单例模式)
            5.如果一个类没有声明任何的类变量，也没有静态代码块，那么可以没有类<clinit>方法

        何时触发初始化
            1.为一个类型创建一个新的对象实例时(比如new、反射、序列化)
            2.调用一个类的静态方法
            3.调用一个类或接口的静态字段
            4.调用JavaAPI的反射方法时(比如调用java.lang.Class中的方法,或者java.lang.reflect包)
            5.初始化一个类的派生类(java虚拟机规范明确要求初始化一个类时,它的超类必须提前完成初始化操作,接口例外)
            6.JVM启动包含main方法的启动类时

6.自定义类加载器
    对于静态字段,只有直接定义这个字段的类才会被初始化,因此通过其子类来引用父类中定义的静态字段,只会触发父类的初始化而不会触发子类的初始化
7.Android ClassLoader
