http://www.importnew.com/7099.html
https://juejin.im/post/5dee6f54f265da33ba5a79c8
1.简单介绍一下hashMap工作原理
    基于MAP接口实现的一种键值对的存储结构
    特点：底层使用数组+链表实现，采用键值对方式存储，key必须唯一，value允许重复，存取无序,key和value可以传入null

    hashMap基于hashing原理,我们通过put和get方法储存和获取对象。
    当我们把键值对传递给put方法时,它调用键对象的hashCode方法来计算hashCode值，然后找到bucket位置来存储值对象
    当我们获取对象时,通过键对象的equals方法找到正确的键值对,然后返回值对象
    hashMap使用链表来解决碰撞问题,当发生碰撞了,对象将会存储在链表的下一个结点中。HashMap在每个链表节点中存储键值对对象

2.hash冲突是什么，为什么会出现hash冲突
    hash冲突：不同的元素，通过hash计算出存放table的索引位置相同

    冲突原因：当我们调用put方法添加key-value键值对的时候，
    这个key-value键值对存放的位置是通过扰动函数(key==null)?0:(h=key.hashCode())^(h>>>16)计算key的hash值
    随后通过这个hash值对哈希表的长度取模%得到具体的存放位置
    所以put多个元素时，是有可能计算出相同的存放位置的，例子如下
        元素A的hash值为9，元素B的hash值为17，table长度是8，则元素A的存放位置是9%8=1，元素B存放位置是17%8=1
        不同的hash值，两个元素的存放位置都是table[1]，就发生了hash冲突或者hash碰撞

    如何解决hash冲突：
        1.JDK8扰动函数避免发生hash冲突：
        /**
        * JDK 7 的 hash 方法
        */
        final int hash( int h ) {
            h ^= k .hashCode();
            h ^= ( h >>> 20) ^ ( h >>> 12);
            return h ^ ( h >>> 7) ^ ( h >>> 4);
        }
        /**
        * JDK 8 的 hash 方法，扰动函数
        */
        static final int hash( Object key ) {
            int h ;
            return ( key == null) ? 0 : ( h = key .hashCode()) ^ ( h >>> 16);
        }

        2.HashMap使用链地址法解决hash冲突
            当有冲突元素存放进来时，会将此元素插入至此位置链表的最后一位，形成单链表
            但是单链表，每当通过hash%length找到该位置的元素时，均需要遍历链表，逐一比较hash值
            如果链表较长，遍历时间增加，最坏情况下时间复杂度为O(N)，造成查询效率慢
            所以当存在链表长度大于等于8时，HashMap会将链表转换成红黑树以提高效率，红黑树最坏情况下时间复杂度为O(logn)

3.hashMap的Put原理
    HashMap使用hashMapEntry<K,V>对象的数组来存放数据。put数据时有以下几个步骤
        1.判断key是否为空值，如果为空值就放在table[0]
        2.通过哈希算法计算key的hash值，通过hash值获取数组存放位置的索引
        3.遍历原数组，如果数组中存在相同的key并且hash值也一样,就返回一个旧值,并且替换旧值
        4.如果不是同一个key,并且hash值没有碰撞,那么就直接存入数组;
        5.如果key不存在，则说明hash值碰撞了，那么就就判断tabel[i]是否是treeNode,
            如果tabel[i]是treeNode，那红黑树直接插入键值对
            如果tabel[i]不是treeNode，就开始遍历链表插入，
                当链表的长度大于8，转换为红黑树插入键值对
                当链表的长度不大于8，则链表插入，如果key存在则直接覆盖value
        6.数组默认长度16,put数据时检测到数组长度大于12(加载因子0.75)时开始以2的整数倍自动扩容
        java8中当链表的节点数量大于8时，链表会转换成红黑树(树化)，当节点数小于6时红黑树会转换成链表

        public V put(K key, V value) {
            // 对key为null的处理
            if (key == null)
                return putForNullKey(value);
            // 根据key算出hash值
            int hash = hash(key);
            // 根据hash值和HashMap容量算出在table中应该存储的下标i
            int i = indexFor(hash, table.length);
            for (Entry<K,V> e = table[i]; e != null; e = e.next) {
                Object k;
                // 先判断hash值是否一样，如果一样，再判断key是否一样
                if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
                    V oldValue = e.value;
                    e.value = value;
                    e.recordAccess(this);
                    return oldValue;
                }
            }
            modCount++;
            addEntry(hash, key, value, i);
            return null;
        }
        void addEntry(int hash, K key, V value, int bucketIndex) {
                // 当前HashMap存储元素的个数大于HashMap扩容的阀值，则进行扩容
                if ((size >= threshold) && (null != table[bucketIndex])) {
                    resize(2 * table.length);
                    hash = (null != key) ? hash(key) : 0;
                    bucketIndex = indexFor(hash, table.length);
                }
                // 使用key、value创建Entry并加入到table中
                createEntry(hash, key, value, bucketIndex);
        }
        void createEntry(int hash, K key, V value, int bucketIndex) {
                // 取出table中下标为bucketIndex的Entry
                Entry<K,V> e = table[bucketIndex];
                // 利用key、value来构建新的Entry
                // 并且之前存放在table[bucketIndex]处的Entry作为新Entry的next
                // 把新创建的Entry放到table[bucketIndex]位置
                table[bucketIndex] = new Entry<>(hash, key, value, e);
                // HashMap当前存储的元素个数size自增
                size++;
            }

    HashMap如何get数据
        首先通过key算出hash值，然后根据hash值算出在table中存储的index，然后遍历table[index]的单向链表去对比key，如果找到了就返回Entry
        public V get(Object key) {
                // 当key为null, 这里不讨论，后面统一讲
                if (key == null)
                    return getForNullKey();
                // 根据key得到key对应的Entry
                Entry<K,V> entry = getEntry(key);
                //
                return null == entry ? null : entry.getValue();
        }

        final Entry<K,V> getEntry(Object key) {
                // 根据key算出hash
                int hash = (key == null) ? 0 : hash(key);
                // 先算出hash在table中存储的index，然后遍历table中下标为index的单向链表
                for (Entry<K,V> e = table[indexFor(hash, table.length)];
                     e != null;
                     e = e.next) {
                    Object k;
                    // 如果hash和key都相同，则把Entry返回
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        return e;
                }
                return null;
        }

4.HashMap为什么是线程不安全的
      因为Hash碰撞和扩容的原因
      1.hash碰撞时，通过拉链法解决碰撞冲突，通过Entry内部的next变量我们知道使用的是链表。
          当多个线程put数据，有两个或以上的key发生hash碰撞时，获取到了同一个链表的结点,那么addEntry必然会发生数据丢失
      2.hashMap扩容时会调用非同步的resize方法，扩容时会生成一个新容量的数组，
          然后对原数组的键值对重新进行计算并写入到新的数组中，之后指向新的数据。
          当多个线程同时put数据时，某个时刻发生扩容resize，那么最终只有一个线程生成的新数组赋值给了table变量，其他线程的数据都会丢失。

5.HashMap的容量为什么是2的n次方
    因为调用put操作添加key-value键值对时，计算元素存放的位置是通过hash值 %模上 哈希表table的长度length计算的
    但是模运算消耗较大，而通过h & (length-1)也可以得到元素存放位置，
    且只有当数组长度是2的N次方时，h & (length-1) 才等价于 h % length ，而且数组长度是2的N次方时发生hash碰撞概率低

6.hashMap和hashTable区别
    1.线程安全与容器整体结构
        hashMap非线程安全,可以存储null键和值
        hashTable线程安全,不可以存储null键和值
    2.容器设定和扩容机制
        hashMap初始化容量是16，以2的整数倍进行扩容
        hashTable初始化容量是11，以2的整数倍+1进行扩容
    3.散列的分布方式(计算存储的位置)
        hashMap是h & (length-1) 或者 h % length
        hashTable是除留余数法计算存储位置的(容量不是2的n次方，不能用位运算替代模运算)，
        int index = (hash & 0x7FFFFFFF) % tab.length

7.hashMap小结
    HashMap是基于哈希表实现的，用Entry[]来存储数据，而Entry中封装了key、value、hash以及Entry类型的next
    HashMap存储数据是无序的
    hash冲突是通过拉链法解决的
    HashMap的容量永远为2的幂次方，有利于哈希表的散列
    HashMap不支持存储多个相同的key，且只保存一个key为null的值，多个会覆盖
    put过程，是先通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，看是否有相同的key存在，存在，则更新value；不存在则插入到table[index]单向链表的表头，时间复杂度为O(n)
    get过程，通过key算出hash，然后用hash算出应该存储在table中的index，然后遍历table[index]，然后比对key，找到相同的key，则取出其value，时间复杂度为O(n)
    HashMap是线程不安全的，如果有线程安全需求，推荐使用ConcurrentHashMap
