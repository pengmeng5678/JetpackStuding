1.自我介绍
    1.基本信息
        面试官好,我叫彭猛,今年27岁,来自湖南常德
    2.公司、岗位及公众方向
        本科毕业将近五年,我从事过两家公司分别是旗翰科技和三宝创新,五年内我工作的岗位都是机器人平台的Android开发
        经历了公司初期的项目应用定制到系统应用的整合与性能优化全过程,具备应用独立开发能力。
        我负责开发并持续维护过的主要项目包括知音、心理咨询、AI助教、高清相机等。

        其中知音可以说是机器人最核心的一个应用,所有涉及人机语音交互相关的功能业务都是以知音为基础进行扩展的。

        心理咨询是一款为幼教行业专门打造的即时通讯类应用,这个应用和Web端建立两层通信,第一层就是音视频实时通话,通话过程中还可以实时变音
        第二层就是依赖系统通信录和服务器建立的socket长连接,应用和Web端可以实时收发图文视频等信息。这样老师在后台就可以以机器人身份了解小朋友的心理状态进而做出专业辅导

        AI助教是一款结合Web后台管理系统在课堂中使用的助教应用,老师在Web后台编辑好课件数据后,可以在机器人上进行播放或者投放到显示屏上,课件数据结合机器人自身语音、灯光、动作为老师提供课堂辅导

        高清相机建立了和嵌入式系统的通信,嵌入式平台的高清相机和JNI层的socket建立了长连接,音视频数据经JNI传递到应用层,高清相机应用作为一个中转站,为机器人平台的所有应用提供数据支撑
        我的自我介绍大概就是这些,谢谢！

2.应用中用到了哪些设计模式
    1.单例模式
        源码中的context.getService(...)就是使用了单例模式,当XXXService对象不存在时就会创建,创建成功就会保存到一个ArrayList中
        语音、导航模块、网络请求等模块
        public class SpeechManager{
            public SpeechManager getInstance(){
                return sSpeechManagerHolder;
            }
            //静态内部类保证类延迟初始化和类加载安全(JVM初始化类是同步的)
            private static SpeechManagerHolder{
                private static SpeechManagerHolder sSpeechManagerHolder = new SpeechManager();
            }
        }

        public class SpeechManager{
            //第一层判空保证性能；第二次判空保证单例(避免两个线程同时通过第一层判断,线程A初始化后,线程B获取锁再创建一次对象);
            //volatile保证有序性
            private volatile mInstance;
            public SpeechManager getInstance(){
                if(mInstance == null){
                    synchronize(SpeechManager.class){
                        if(mInstance == null){
                            mInstance = new SpeechManager();
                        }
                    }
                }
                return mInstance;
            }
    2.观察者模式
        源码中的Adapter就是一个观察者模式,Adapter内部包含一个被观察者对象DataSetObservable,我们通过listView.setAdapter其实就是创建了一个观察者,
        我们调用Adapter.notifyDatasetChange方法,就会调用DataSetObservable的setChange方法让所有的观察者重新绘制

        高清相机中JNI层的数据流传递到应用层后,一方面我们要显示,一方面我们要推送给服务器就构成了一种一对多的依赖关系
        我们统一管理所有监听者的请求来统一通知所有的观察者
        public class Observerable{

            private Vector<Observer> vector = new Vector()
            public synchronized void registerObServer(Observer observer){
                if(!vector.contains(observer)){
                    list.add(observer)
                }
            }
            public synchronized void unregisterObserver(Observer observer){
                list.remove(observer)
            }
            public void publishData(String data){
                for(int i=0;i<list.size;i++){
                    list.get(i).updateData(data);
                }
            }
        }
        public class Observer{
            public updateData(String data)
        }
        public class Client(){
            Observer observer1 = new Observer();
            Observer observer2 = new Observer();
            Observer Observerable = new Observerable();
            Observerable.registerObServer(observer1)
            Observerable.registerObServer(observer2)
        }
    3.Builder模式
        源码中的AlertDialog.Builder
        在心理咨询项目中,对音视频推流的参数配置上采用了Builder模式
        public class pushManager{
            private String simpleRate;
            private int simpleBit;
            private String chanelType;
            public pushManager(Builder build){
                simpleRate = build.mSimpleRate;
                simpleBit  = build.msimpleBit;
                chanelType = build.mChanelType;
            }
            public static class Builder{
                private String mSimpleRate;
                private int    mSimpleBit;
                private String mChanelType;
                public Builder simpleRate(String simpleRate){
                    this.mSimpleRate = simpleRate;
                    return this;
                }
                public Builder simpleRate(String simpleBit){
                    this.mSimpleBit = simpleRate;
                    return this;
                }
                public Builder simpleRate(String chanelType){
                    this.mChanelType = simpleRate;
                    return this;
                }
                public pushManager build(){

                    return new pushManager(this)
                }
            }
        }

    4.外观模式
        源码中ComtextImpl
        语音模块中使用了外观模式统一调配语音的识别、合成、唤醒、语义功能

3.应用中用到了哪些数据结构和算法
    知音中使用了HashMap保存缓存的Fragemnt
    LindkedHashMap
    AI助教中使用了递归解析硬件协议的算法
4.说说面向对象设计思想
    理解的面向对象设计思想它是一种“万物皆对象”的设计思想,现实世界中任何一个物体都可以属于某一类事物,
    每一个个体就可以理解这类事物的一个实体。面向对象的编程就是以对象为中心,结合消息驱动，所以程序=对象+消息。
    面向对象有三大特性
        封装：将一类事物的属性和行为抽象成一个类。使其属性私密化和行为公开化。保证了数据的隐秘性,提高代码复用性
        继承：将一类事物的共有属性和行为抽象成一个父类,使其子类可以使用父类的属性和行为,也可以自己扩展自己的属性和行为，提高代码的扩展性和复用性
        多态：将父类引用指向子类对象，它通过接口重用,使其调用父类接口的方法时,不同的子类实现的逻辑也不同,从而达到解耦的目的
5.说说Handler机制
    定义、本质、实现原理
6.内存模式和垃圾回收机制
    内存模式定义
    垃圾回收机制
        检测垃圾和回收垃圾
7.线程池
    自定义和Executors方式创建线程池
    Executors.newFixThreadPool和Executors.newCacheThreadPool的区别
8.说说内存泄漏和内存优化
    内存泄漏的本质其实是长生命周期对象持有短生命周期对象的引用,导致短生命周期对象无法被有效回收
    内存泄漏的场景:单例持有Activity引用;非静态内部类创建了静态实例;Handler无法立即处理所有MessageQueue中的消息
    如何优化内存泄漏:
        1.结合场景给出解决方案
        2.使用LeakCanary检测所有内存泄漏结合MAT分析解决内存泄漏
9.说说Binder机制
    基本介绍及功能:
        Binder是Android系统独有的一套进程间通信机制
        相对于传统IPC方式,Binder机制在传递数据时只需要采用一次拷贝操作,提高了效率,节省了内存空间

        Binder具体提供的功能
            1.使用驱动程序推进进程间通信
            2.使用共享内存提高效率
            3.为每一对Serve进程和Client进程维护了一个Binder线程池
            4.针对系统的对象引入和跨进程对象的引用映射
            5.进程间同步调用
    使用场景:
        启动应用时Launcher和AMS通信
        Zygote和应用进程
        应用进程间的AIDL
        ActivityManager和ActivityManagerService的桥梁
    通信过程：
        Binder通信过程是一种C/S结构的通信结构,具体通信过程如下
        1.Client端绑定Server端获取一个Server端的代理接口
        2.Server端的代理接口和Server中定义的方法时一一对应的
        3.Client端调用这个代理接口方法时,代理接口会将数据打包成Parcel对象
        4.代理接口将Parcel发送给内核的Binder Driver
        5.Server端读取Binder Driver中请求的数据,如果是发送给自己的,就会解析处理后返回给客户端
        6.整个通信过程是同步的,Server处理的时候,Client会阻塞

10.网络通信
    1.网络五层/七层模型
        应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
        应用层、传输层、网络层、数据链路层、物理层
    2.TCP/UDP特点及异同
        TCP     面向连接      可靠    面向字节流   速度慢
        UDP     无连接       不可靠    数据报文端   速度快
    3.TCP三次握手和四次挥手
        三次握手
           1.客户端向服务端发起连接请求，向服务端发送SYN=1,SquenceNum置为随机数X,客户端进入SYN+SEND状态
           2.服务端收到客户端的请求,对请求进行校验,然后将AcknowledgeNum置为X+1,同时自己也发送一个SYN报文段,将SYN置为1,将squnceNum置为Y
           3.客户端接收到服务端的回复,将acknowledgeNum置为Y+1,向服务器发送ACK报文段,至此客户端和服务端正式建立了连接,并进入ESTEBLISHED状态
        四次挥手
           1.客户端(或服务器)向服务端发起断开连接请求,客户端发送一个FIN报文段,设置sequnceNum和Acknowledgement num,客户端进入一个Close_WAIT_1状态
           2.服务端收到FIN报文段后,并将Acknowledgement num+1,向客户端回复一个ACK报文段,表示同意客户端的关闭连接请求
           3.服务端处理完相应的逻辑后,向客户端发送一个FIN报文段,发起关闭连接请求
           4.客户端收到FIN报文段后,给服务端回复一个ACK报文段,就关闭连接,如果2ms内服务器没有发送消息过来,那么TCP连接就断开了

    4.Http和Https区别
        https是在Http的基础上加入了一层安全套接字SSL(Secure socket layer)
        传统的Http是直接和TCP通信，而Https是先和SSL进行通信，然后SSL再和TCP通信

        而https保证安全的原理是使用的对称加密+非对称加密结合的方式保证的
            1.客户端发起请求，生成随机数1
            2.服务端收到请求,生成随机数2,并发送CA证书，并确认加密方式是非对称加密
            3.客户端校验证书,生成随机数3，并用证书中的公钥加密发送给服务端
            4.服务端根据随机数1/2/3并结合算法生成一个秘钥，作为后面对称加密的秘钥，同时客户端也根据随机数1/2/3并结合算法生成一个私钥
            6.后面的传输过程就通过这个秘钥加密传输

    5.Okhttp实现原理
        1.基本使用及特点
            使用：
                OkHttpClient client = new OkHttpClient.Builder().addIntercepter(..).build();
                Request request = new Request.Builder().url(..).header(..);
                client.newCall(request).enqueue(call);
            特点
                OkHttp是Square[skwer]公司开源的一个用于网络请求的开源框架,它包含以下特点
                    支持Http2,对一台机器的所有请求共享同一个socket,提高请求效率
                    内置连接池,支持连接复用,减少延迟
                    支持透明的gzip压缩响应体
                    通过缓存避免重复的请求
                    请求失败时自动重试主机的其他IP,自动重定向

        2.整体调用流程图

        3.拦截链实现原理
            请求条件：最多支持64个请求,且同一个主机的请求数不能超过5
            1.添加请求任务
                client.newCall(request).enqueue(call);
                Dispather中三个ArrayDeque双端队列：readyAsyncCalls,runningAsyncCalls,runningSyncCalls
                enqueue异步调用如果满足请求条件就放入runningAsyncCalls,如果不满足就放入readyAsyncCalls
                execute同步调用直接放入runningSyncCalls
                    如果是添加到runningxxx的容器中就会调用executorService().execute(call);
                    并最终调用到AsycCall的execute方法
                        @Override protected void execute() {
                              boolean signalledCallback = false;
                              try {
                                Response response = getResponseWithInterceptorChain();
                                if (retryAndFollowUpInterceptor.isCanceled()) {
                                  signalledCallback = true;
                                  responseCallback.onFailure(RealCall.this, new IOException("Canceled"));
                                } else {
                                  signalledCallback = true;
                                  responseCallback.onResponse(RealCall.this, response);
                                }
                              } catch (IOException e) {
                                if (signalledCallback) {
                                  // Do not signal the callback twice!
                                  Platform.get().log(INFO, "Callback failure for " + toLoggableString(), e);
                                } else {
                                  responseCallback.onFailure(RealCall.this, e);
                                }
                              } finally {
                                //这个finish方法会调用promoteCalls将readyAsyncCalls的任务移到runningAsyncCalls并执行这个任务
                                client.dispatcher().finished(this);
                              }
                            }
                          }

            2.执行任务时机
                1.添加到runningxxx的容器中就会直接执行executorService().execute(call);
                2.调用Dispather类中promoteCalls方法将readyAsyncCalls的任务移到runningAsyncCalls并执行这个任务
                  promoteCalls在以下三种情况会被调用
                        1.client.dispatcher().finished(this)
                        2.dispather().setMaxRequests
                        3.dispather().setMaxRequestsPerHost
            3.链式调用
                Response response = getResponseWithInterceptorChain();

                public interface Interceptor {
                  Response intercept(Chain chain) throws IOException;
                  interface Chain {
                    Request request();
                    Response proceed(Request request) throws IOException;
                    @Nullable Connection connection();
                  }
                }
                1.准备所有的Interceptor列表,并调用RealInterceptorChain的proceed方法
                    Response getResponseWithInterceptorChain() throws IOException {
                        // Build a full stack of interceptors.
                        List<Interceptor> interceptors = new ArrayList<>();
                        interceptors.addAll(client.interceptors());
                        interceptors.add(retryAndFollowUpInterceptor);
                        interceptors.add(new BridgeInterceptor(client.cookieJar()));
                        interceptors.add(new CacheInterceptor(client.internalCache()));
                        interceptors.add(new ConnectInterceptor(client));
                        if (!forWebSocket) {
                          interceptors.addAll(client.networkInterceptors());
                        }
                        interceptors.add(new CallServerInterceptor(forWebSocket));

                        Interceptor.Chain chain = new RealInterceptorChain(
                            interceptors, null, null, null, 0, originalRequest);
                        return chain.proceed(originalRequest);
                      }

                2.在RealInterceptorChain的proceed方法里面创建一个新的RealInterceptorChain,并保留已有的request或者response书籍
                    并从Interceptor列表拿出一个新的interceptor,并调用intercept方法

                    RealInterceptorChain next = new RealInterceptorChain(
                          interceptors, streamAllocation, httpCodec, connection, index + 1, request);
                      Interceptor interceptor = interceptors.get(index);
                      Response response = interceptor.intercept(next);

                3.interceptor的实现类中的intercept方法会执行自身的逻辑并调用proceed方法找下一个Interceptor
                       response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null);

                getResponseWithInterceptorChain这个方法采用递归调用方式,
             依次调用了以下拦截链封装Request请求参数到CallServerInterceptor等服务器返回,然后又依次返回并封装Response对象
                    1.CustomInterceptor             :自定义的拦截链，如日志和下载进度
                    2.RetryAndFollowUpInterceptor   :重定向和失败重连
                    3.BridgeInterceptor             :负责对Request和Response报文加工,将应用层与网络层的数据结构进行相互转换
                    4.CacheInterceptor              :请求和响应数据缓存处理,避免重复请求,提高响应速度
                    5.ConnectInterceptor            :和服务器开始建立连接
                    6.NetWorkInterceptor            :用户自定义的Interceptor，仅在生产网络请求时时生效
                    7.CallServerInterceptor         :向服务器发起网络请求的地方
    6.Retrofit特点及实现原理
        1.介绍
            Restrofit是Square公司开源的基于OkHttp,且符合Restful设计风格的网络请求框架
            优点
                1.功能强大:支持同步异步请求,同时支持Rxjava
                2.简洁易用：采用注解方式配置网络请求参数,采用大量的设计模式简化使用
                3.可扩展性好:高度封装功能模块,解耦彻底,方便扩展，如自定义converter
        2.使用
            1.创建Retrofit对象
                Retrofit retorfit = new Retrofit.Builder()
                    .addCoverterFactory(GsonConverterFactory.create())
                    .baseUrl(xxx)
                    .build()
            2.声明接口,创建网络请求接口的实例
                public interface NewsService{
                    @Get("news/{newsId}")
                    call<News> getNews(@path("newsId") int newId)
                    //Observeable<News> getNews(@path("newsId") int newId)
                }
            3.发起网络请求
                NewServer service =retrofit.create(NewsService.class)
                Call<News> call = service.getNews(..)
                call.execute()或者call.enqueue()
                //Observeable<News> observeable = service.getNews(..)
                observeable.createXXX().subscribe(xxx)
            4.处理数据的回调

            Retrofit配置网络请求接口时,请求参数中使用的字段
                1.path:url问号前面的字段
                2.Query:url问号后面的字段
                3.filed:用于post请求,提交单个数据
                4.Body:用于post请求,以对象的形式提交
        3.实现原理
            Retrofit本质上是在OkHttp框架基础上使用了大量的设计模式进行封装,使得它简洁易用。
            精髓是用动态代理的方式动态的将网络请求接口中的注解解析成HTTP请求并发起网络调用,具体过程如下
                1.创建Retrofit实例
                    建造者模式,配置了平台类对象、baseUrl、数据转换工厂、回调方法执行器callbackExcutor(线程切换)
                    工厂方法模式,配置了callFactory,默认使用OkHttpCall
                2.创建网络请求接口的实例
                    代理模式,动态代理方式创建了网络请求接口实例
                    建造者模式,用ServiceMethod对象封装网络请求参数、返回值、注解类型等
                3.发送网络请求
                    根据ServiceMethod对象中的数据创建一个Okhttp的requst对象
                    代理模式,通过静态代理即Okhttp.call对象发送网络请求
                4.解析数据
                    对OkHttp返回的数据采用GsonConvertorFactory解析成Response对象
                5.切换线程
                    适配器模式,使用回调执行器进行线程切换(Handler)
                6.处理结果
                    在主线程处理返回的数据结果
11.Rxjava
12.音视频的采集和编解码












