1.自我介绍
    1.基本信息
        面试官好,我叫彭猛,今年27岁,来自湖南常德
    2.公司、岗位及公众方向
        本科毕业将近五年,我从事过两家公司分别是旗翰科技和三宝创新,五年内我工作的岗位都是机器人平台的Android开发
        经历了公司初期的项目应用定制到系统应用的整合与性能优化全过程,具备应用独立开发能力。
        我负责开发并持续维护过的主要项目包括知音、心理咨询、AI助教、高清相机等。

        其中知音可以说是机器人最核心的一个应用,所有涉及人机语音交互相关的功能业务都是以知音为基础进行扩展的。

        心理咨询是一款为幼教行业专门打造的即时通讯类应用,这个应用和Web端建立两层通信,第一层就是音视频实时通话,通话过程中还可以实时变音
        第二层就是依赖系统通信录和服务器建立的socket长连接,应用和Web端可以实时收发图文视频等信息。这样老师在后台就可以以机器人身份了解小朋友的心理状态进而做出专业辅导

        AI助教是一款结合Web后台管理系统在课堂中使用的助教应用,老师在Web后台编辑好课件数据后,可以在机器人上进行播放或者投放到显示屏上,课件数据结合机器人自身语音、灯光、动作为老师提供课堂辅导

        高清相机建立了和嵌入式系统的通信,嵌入式平台的高清相机和JNI层的socket建立了长连接,音视频数据经JNI传递到应用层,高清相机应用作为一个中转站,为机器人平台的所有应用提供数据支撑
        我的自我介绍大概就是这些,谢谢！

2.应用中用到了哪些设计模式
    1.单例模式
        源码中的context.getService(...)就是使用了单例模式,当XXXService对象不存在时就会创建,创建成功就会保存到一个ArrayList中
        语音、导航模块、网络请求等模块
        public class SpeechManager{
            public SpeechManager getInstance(){
                return sSpeechManagerHolder;
            }
            //静态内部类保证类延迟初始化和类加载安全(JVM初始化类是同步的)
            private static SpeechManagerHolder{
                private static SpeechManagerHolder sSpeechManagerHolder = new SpeechManager();
            }
        }

        public class SpeechManager{
            //第一层判空保证性能；第二次判空保证单例(避免两个线程同时通过第一层判断,线程A初始化后,线程B获取锁再创建一次对象);
            //volatile保证有序性
            private volatile mInstance;
            public SpeechManager getInstance(){
                if(mInstance == null){
                    synchronize(SpeechManager.class){
                        if(mInstance == null){
                            mInstance = new SpeechManager();
                        }
                    }
                }
                return mInstance;
            }
    2.观察者模式
        源码中的Adapter就是一个观察者模式,Adapter内部包含一个被观察者对象DataSetObservable,我们通过listView.setAdapter其实就是创建了一个观察者,
        我们调用Adapter.notifyDatasetChange方法,就会调用DataSetObservable的setChange方法让所有的观察者重新绘制

        高清相机中JNI层的数据流传递到应用层后,一方面我们要显示,一方面我们要推送给服务器就构成了一种一对多的依赖关系
        我们统一管理所有监听者的请求来统一通知所有的观察者
        public class Observerable{

            private Vector<Observer> vector = new Vector()
            public synchronized void registerObServer(Observer observer){
                if(!vector.contains(observer)){
                    list.add(observer)
                }
            }
            public synchronized void unregisterObserver(Observer observer){
                list.remove(observer)
            }
            public void publishData(String data){
                for(int i=0;i<list.size;i++){
                    list.get(i).updateData(data);
                }
            }
        }
        public class Observer{
            public updateData(String data)
        }
        public class Client(){
            Observer observer1 = new Observer();
            Observer observer2 = new Observer();
            Observer Observerable = new Observerable();
            Observerable.registerObServer(observer1)
            Observerable.registerObServer(observer2)
        }
    3.Builder模式
        源码中的AlertDialog.Builder
        在心理咨询项目中,对音视频推流的参数配置上采用了Builder模式
        public class pushManager{
            private String simpleRate;
            private int simpleBit;
            private String chanelType;
            public pushManager(Builder build){
                simpleRate = build.mSimpleRate;
                simpleBit  = build.msimpleBit;
                chanelType = build.mChanelType;
            }
            public static class Builder{
                private String mSimpleRate;
                private int    mSimpleBit;
                private String mChanelType;
                public Builder simpleRate(String simpleRate){
                    this.mSimpleRate = simpleRate;
                    return this;
                }
                public Builder simpleRate(String simpleBit){
                    this.mSimpleBit = simpleRate;
                    return this;
                }
                public Builder simpleRate(String chanelType){
                    this.mChanelType = simpleRate;
                    return this;
                }
                public pushManager build(){

                    return new pushManager(this)
                }
            }
        }

    4.外观模式
        源码中ComtextImpl
        语音模块中使用了外观模式统一调配语音的识别、合成、唤醒、语义功能

3.应用中用到了哪些数据结构和算法
    知音中使用了HashMap保存缓存的Fragemnt
    LindkedHashMap
    AI助教中使用了递归解析硬件协议的算法
4.说说面向对象设计思想
    理解的面向对象设计思想它是一种“万物皆对象”的设计思想,现实世界中任何一个物体都可以属于某一类事物,
    每一个个体就可以理解这类事物的一个实体。面向对象的编程就是以对象为中心,结合消息驱动，所以程序=对象+消息。
    面向对象有三大特性
        封装：将一类事物的属性和行为抽象成一个类。使其属性私密化和行为公开化。保证了数据的隐秘性,提高代码复用性
        继承：将一类事物的共有属性和行为抽象成一个父类,使其子类可以使用父类的属性和行为,也可以自己扩展自己的属性和行为，提高代码的扩展性和复用性
        多态：将父类引用指向子类对象，它通过接口重用,使其调用父类接口的方法时,不同的子类实现的逻辑也不同,从而达到解耦的目的
5.说说Handler机制
    定义本质实现原理
6.内存模式和垃圾回收机制
    内存模式定义
    垃圾回收机制
        检测垃圾和回收垃圾
7.线程池
    自定义和Executors方式创建线程池
    Executors.newFixThreadPool和Executors.newCacheThreadPool的区别
8.说说内存泄漏和内存优化
    内存泄漏的本质其实是长生命周期对象持有短生命周期对象的引用,导致短生命周期对象无法被有效回收
    内存泄漏的场景:单例持有Activity引用;非静态内部类创建了静态实例;Handler无法立即处理所有MessageQueue中的消息
    如何优化内存泄漏:
        1.结合场景给出解决方案
        2.使用LeakCanary检测所有内存泄漏结合MAT分析解决内存泄漏
9.说说Binder机制
    基本介绍及功能:
        Binder是Android系统独有的一套进程间通信机制
        相对于传统IPC方式,Binder机制在传递数据时只需要采用一次拷贝操作,提高了效率,节省了内存空间

        Binder具体提供的功能
            1.使用驱动程序推进进程间通信
            2.使用共享内存提高效率
            3.为每一对Serve进程和Client进程维护了一个Binder线程池
            4.针对系统的对象引入和跨进程对象的引用映射
            5.进程间同步调用
    使用场景:
        启动应用时Launcher和AMS通信
        Zygote和应用进程
        应用进程间的AIDL
        ActivityManager和ActivityManagerService的桥梁
    通信过程：
        Binder通信过程是一种C/S结构的通信结构,具体通信过程如下
        1.Client端绑定Server端获取一个Server端的代理接口
        2.Server端的代理接口和Server中定义的方法时一一对应的
        3.Client端调用这个代理接口方法时,代理接口会将数据打包成Parcel对象
        4.代理接口将Parcel发送给内核的Binder Driver
        5.Server端读取Binder Driver中请求的数据,如果是发送给自己的,就会解析处理后返回给客户端
        6.整个通信过程是同步的,Server处理的时候,Client会阻塞

10.网络通信
    1.网络五层/七层模型
        应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
        应用层、传输层、网络层、数据链路层、物理层
    2.TCP/UDP特点及异同
        TCP     面向连接      可靠    面向字节流   速度慢
        UDP     无连接       不可靠    数据报文端   速度快
    3.TCP三次握手和四次挥手
        三次握手
           1.客户端向服务端发起连接请求，向服务端发送SYN=1,SquenceNum置为随机数X,客户端进入SYN+SEND状态
           2.服务端收到客户端的请求,对请求进行校验,然后将AcknowledgeNum置为X+1,同时自己也发送一个SYN报文段,将SYN置为1,将squnceNum置为Y
           3.客户端接收到服务端的回复,将acknowledgeNum置为Y+1,向服务器发送ACK报文段,至此客户端和服务端正式建立了连接,并进入ESTEBLISHED状态
        四次挥手
           1.客户端(或服务器)向服务端发起断开连接请求,客户端发送一个FIN报文段,设置sequnceNum和Acknowledgement num,客户端进入一个Close_WAIT_1状态
           2.服务端收到FIN报文段后,并将Acknowledgement num+1,向客户端回复一个ACK报文段,表示同意客户端的关闭连接请求
           3.服务端处理完相应的逻辑后,向客户端发送一个FIN报文段,发起关闭连接请求
           4.客户端收到FIN报文段后,给服务端回复一个ACK报文段,就关闭连接,如果2ms内服务器没有发送消息过来,那么TCP连接就断开了

    4.Http和Https区别
        https是在Http的基础上加入了一层安全套接字SSL(Secure socket layer)
        传统的Http是直接和TCP通信，而Https是先和SSL进行通信，然后SSL再和TCP通信

        而https保证安全的原理是使用的对称加密+非对称加密结合的方式保证的
            1.客户端发起请求，生成随机数1
            2.服务端收到请求,生成随机数2,并发送CA证书，并确认加密方式是非对称加密
            3.客户端校验证书,生成随机数3，并用证书中的公钥加密发送给服务端
            4.服务端根据随机数1/2/3并结合算法生成一个秘钥，作为后面对称加密的秘钥，同时客户端也根据随机数1/2/3并结合算法生成一个私钥
            6.后面的传输过程就通过这个秘钥加密传输

    5.Okhttp实现原理

    6.Retrofit特点及实现原理










