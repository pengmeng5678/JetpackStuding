https://www.jianshu.com/p/02962454adf7
https://www.zhihu.com/question/34652589
原理分析：https://www.jianshu.com/p/f0b23ee5a922
源码分析：https://www.jianshu.com/p/b4d745c7ff7a
https://blog.csdn.net/qian520ao/article/details/78262289
1.Handler简介
    Handler是一套Android消息传递机制
        本质：一个线程开启循环模式持续监听并依次处理其他线程给它发的消息
        作用：将工作线程需要操作UI的消息传递到主线程,使得主线程可以根据工作线程的需求更新UI,从而避免线程操作不安全的问题

2.Handler机制原理
    Handler机制的工作流程主要包括4个步骤
    1.异步通信准备
        主线程中创建Looper、MessageQueue、Handler;创建MessageQueue后,Looper自动进入消息循环；Handler自动绑定了主线程的Looper和MessageQueue
    2.消息入队
        工作线程通过Handler发送消息(Message)到消息队列(MessageQueue),messageQueue.enqueMessage
    3.消息循环
        消息出队:Looper循环取出消息队列(MessageQueue)中的消息(MessageQueue),Message msg = queue.next();
        消息分发:Looper将取出的消息发送给创建该消息的处理者(Handler),msg.target.dispatchMessage
    4.消息处理
        处理者(Handler)接收处理器Looper发送过来的消息
        处理者根据Message执行UI操作

3. Looper、Handler、MessageQueue、Message作用和存在的意义
    Looper:
        主线程中的Looper是个死循环不断等其他线程给它发消息(Activity启动、生命周期、更新UI、控件事件等),另一部分工作就是在循环代码中不断从消息队列挨个拿出消息给主线程处理
    handler:
        1.用于同一个进程的线程间通信。如果在主线程中创建Handler对象,那这个Handler就获取了主线程MessageQueue的引用,就可以往队列里插入新消息了
        2.另一个作用可以统一处理消息的回调
    MessageQueue:
        多个线程往主线程的MessageQueue发消息时,用队列来保存消息和安排每个消息的处理顺序
    Message
        消息的载体

4.注意点
    1.一个线程只能绑定一个Looper,但可以有多个Handler
    2.一个Looper可以绑定多个处理者
    3.一个Handler，只能绑定一个Looper

5.Handler源码分析
    1.Activity的main方法执行
        //在Android应用进程启动的时候,会默认创建一个主线程ActivityThread,同时调用静态的main方法
        public static void main(){
            //创建Looper对象同时生成一个消息队列对象
            Looper.prepareMainLooper();
            ActivityThread thread = new ActivityThread();
            //自动开启消息循环
            Looper.loop();
         }
    2.准备Looper和MessageQueue
         1.Looper.prepare
            public static final void prepare(){
                    if(mThreadLocal.get() != null){
                        抛RuntimeException   //同一个线程不能prepare两次
                    }
                    sThreadLocal.set(new Looper(true))//创建Looper对象,并且存入到ThreadLocal里面
                }
            }
            作用：为当前工作线程创建一个Looper,同时也生成了1个消息队列对象。
            子线程中创建handler的前提是需要程序员在线程中主动调用Looper.prepare,和Looper.loop启动消息循环

        2.Looper.prepareMainLooper
          public static void prepareMainLooper() {
            prepare(false);
             synchronized (Looper.class) {
                if (sMainLooper != null) {
                    throw new IllegalStateException("The main Looper has already been prepared.");
                }
                sMainLooper = myLooper();
             }
           }

    2.消息循环
        public Looper(){
            mQueue = new MessageQueue(quitAllowed)
            mThread = Thread.currentThread();
        }
        public static void loop(){
            //1.获取当前Looper的消息队列。myLooper返回sThreadLocal存储的Looper实例
            final Looper me = myLooper()
            final MessageQueue queue = me.mQueue;
            //2.消息循环
            for(;;){
                Message msg = queue.next();
                if(msg == null){
                    return;
                }
                //target其实就是创建该消息的Handler对象
                msg.target.dispatchMessage(msg)
                msg.recycle();
            }
        }

    3.用户创建Handler,执行Handler的构造方法
            public handler(){
                this(null,false)
            }
            public Handler(Callback callback,boolea async){
                //如果在子线程直接创建handler就会抛异常,所以应该创建前调用Looper.prepare,然后主动调用Looper.prepare操作
                mLooper = Looper.myLooper()
                mQueue = mLooper.mQueue;
            }
6.ThreadLocal
      1.作用
          ThreadLocal的作用是提供线程内的局部变量,在本地线程内随时随地可取,隔离其他线程。这种局部变量仅仅在线程的生命周期内起作用。
          比如Looper.prepare方法,创建后的Looper对象就是保存到ThreadLoacal里面的,这样就保证了每个线程对应一个唯一的Looper

      2.ThreadLocal的大致实现思路
          Thread类中有个ThreadLocal.ThreadLocalMap的实例变量,所以说每个线程都有一个自己的ThreadLocalMap,ThreadLocalMap有自己的独立实现
          可以简单的将它的key视为ThreadLocal(实际不是ThreadLocal本身,而是它的一个WeakRefrence弱引用),value视为存入的值
          所以每个线程往ThreadLocal里面存的值,都是往自己类里面的ThreadLocalMap里面存,读也是从某个ThreadLocal为引用,在自己的map里面找对应的key,从而实现了线程隔离

      3.java ThreadLocal的常用方法
            public void set(T value) {//设置当前线程的线程局部变量
                Thread t = Thread.currentThread();
                ThreadLocalMap map = getMap(t);//获取当前线程的ThreaLocalMap对象
                if (map != null)
                    map.set(this, value);
                else
                    createMap(t, value);
            }
            public T get() {//返回当前线程所对应的线程局部变量
                Thread t = Thread.currentThread();
                ThreadLocalMap map = getMap(t);
                if (map != null) {
                    ThreadLocalMap.Entry e = map.getEntry(this);
                    if (e != null)
                        return (T)e.value;
                }
                return setInitialValue();
            }
7.常见问答

    1.为什么主线程的Looper死循环不会导致卡顿

    2.子线程可以使用handler吗
        可以，参考HandlerThread,前提是要在子线程使用handler需要先在子线程调用Looper.prepare和Looper.loop方法，然后创建handler时绑定这个已经初始化过的Looper
        主线程可以创建Handler直接使用，是因为默认使用了主线程的handler(在ActivityThread默认初始化了Looper)
    3.为什么子线程不可以操作UI
        因为UI只能在它创建的线程下才能更新
    4.一个线程可以有多少个Handler
        1个，因为我可以在Activity创建多个Handler对象
    5.一个线程可以绑定多少个Looper，如何保证
        1个，因为Looper.prepare方法会通过ThreadLocal将Looper和当前线程进行绑定，且一个线程的prepare方法只能调用一次
    6.handler为什么会产生内存泄露？
        匿名内部类持有了外部类的引用(可以调用外部类的方法)，如果Activity中创建了匿名内部类handler，那么handler就持有了Activity的引用
        而handler中的messageque可能是延迟消息，当垃圾回收时，发现activity是可达的，就不会回收activity
        解决方案：1.将handler设置为静态的，用软引用或弱引用持有activity；2.在ondestroy方法中清除handler所有的消息
            private static class MyHandler extends Handler{
                private final WeakReference<Activity> mActivity;
                public MyHandler(Activity activity) {
                    mActivity = new WeakReference<Activity>(activity);
                }
                @Override
                public void handleMessage(Message msg) {
                    System.out.println(msg);
                    if(mActivity.get() == null) {
                        return;
                    }
                }
            }

8.Handler的消息延时是怎么实现的
    1.消息延时是做了什么特殊处理吗
        消息队列按消息触发时间排序,越早触发的消息越排在队列的前面
    2.是发送延时了还是消息处理延时了,如何保证在延时时间点触发消息呢?
        消息处理延时了,设置epoll_wait的超时时间,使其在特定时间唤醒
    3.延时的精度怎么样
        精度不高,因为依赖epoll_wait的超时时间，且上一个消息处理时间不确定,会影响取下一条消息

9.说说idleHandler的原理
    public static interface idleHandler{
        boolean queueIdle()
    }
    1.idleHandler的作用及调用方式
        IdleHandler是MessageQueue类中的一个接口
        当messageQueue中没有消息了，或者所有的消息都还未到触发时间(pending message),就会回调queueIdle
        当我们在queueIdle中返回false后,那这个queueIdle后面就不会再回调了
    2.idleHandler的使用场景
        比如延迟初始化,检测到当handler空闲的时候再给某些模块初始化
    3.idleHandler的实现原理
        messageQueue的next方法中会判断当前队列是否空闲了,如果是就会回调queueIdle
    4.dleHandler的基本使用
        private MessageQueue.IdleHandler mIdleHandler = new MessageQueue.IdleHandler(){
            public boolean queueIdel(){
                return true
            }
        }
10.主线程进入了loop循环了为什么没有ANR
    1.了解ANR触发的原理
        在AMS中的子线程中弹出了一个dialog提示用户,应用无响应
        final void appNotResponding(ProcessRecord app,...){
            Message msg = Message.obtain()
            msg.what = SHOW_NOT_RESPONDING_MSG
            mUiHandler.sendMessage(msg)//Dialog d = new AppNotRespondingDialog();d.show()
        }
        触发ANR的原因有以下几种
            1.主线程耗时操作
                serviceTimeout
                broadcastTimeout
                providerTimeout
                inputDispatching Timeout
            2.其他进程占用CPU太多导致当前进程无法获取到CPU时间片
            3.主线程被其他线程锁死
        如ServiceTimeout是在realStartServiceLocked中触发的
        void realStartServiceLocked(ServiceRecord,ProcessRecord app,...){
            bumpServiceExecutionLocked(r,execInFg,"create")//执行scheduleServiceTimeoutLocked(r.app)
            app.thread.scheduleCreateService(r,r.serviceInfo)
        }
    2.了解应用大致启动流程
    3.了解线程的消息循环机制
    4.了解应用和系统的通信过程
    5.Android中为什么主线程不会因为Looper.loop()里的死循环卡死？
         Looper的loop函数在一个死循环中通过MessageQueue调用next函数(调用底层的nativePollOnce函数),这个next函数在没有消息时会阻塞休眠,但不会占用CPU资源
         当有消息过来的时候便会唤醒这个handler处理消息。
         这个机制就是Linux的epoll模型
            当没有消息的时候会epoll.wait,等待句柄写的时候再唤醒,这个时候是阻塞的
            所有的UI刷新都是通过handler发消息,如屏幕刷新就会有句柄写的操作,唤醒上文的wait操作,所以不会卡死
         既然是死循环又如何去处理其他事务呢？
            答案是通过创建新线程的方式,ActivityThread的main方法中的activityThread.attach方法就是绑定了Binder线程(ApplicationThread会接收AMS发送过来的Binder消息)
            该Binder线程通过Handler将Message发送给主线程

11.说说消息屏障
    1.什么是消息屏障
        插入一个消息屏障之后,会优先执行这个消息屏障,且后面的同步消息会被阻塞(不会阻塞异步消息),比如每次屏幕刷新信号vSync信号来的时候,就会插入一个消息屏障,待下一次Vsync信号来时优先执行屏幕绘制工作
        private int postSyncBarrier(long when){
            sychrounized(this){
                final int token = mNextBarrierToken++;
                final Message msg = Message.obtain()
                msg.markInUse()
                msg.when = when
                msg.arg1 = token
                //给这个msg按时间顺序插入到消息队列中
                return token
            }
        }
        插入屏障消息的特点
            1.这个消息没有handler，不需要分发
            2.这个消息带有时间戳,会影响后面消息的分发
            3.消息队列是可以插入多个消息屏障的
            4.没有唤醒线程
            5.插入屏障消息会返回一个token,便于执行屏障消息后移除这个消息屏幕

    2.什么场景下会使用消息屏障
        scheduleTraversals方法中会插入一个消息屏障拦截所有同步消息的执行,优先等待执行屏幕刷新工作
        当Vsync信号来了执行doTraversal方法时就会执行移除屏障消息
    3.消息屏障实现原理是什么