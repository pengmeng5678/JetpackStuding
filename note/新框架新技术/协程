https://juejin.cn/post/6854573211418361864
一、基本介绍
    定义：轻量级的线程
    优点：可以通过阻塞的方式写出非阻塞的代码，解决常见的回调地狱，还可以结合jetpack相关组件一起使用

二、基本使用
    GlobalScope.launch(Dispatchers.IO){//}
    上面代码包含三个部分，Global、Dispatcher、launch，分别表示：
        1.协程作用域：
            三种作用域类型
            runblocking:顶层函数，它会阻塞当前线程来等待，所以在业务中不适用
            GlobalScope:全局协程作用域，可以在整个应用的生命周期中操作，且不能取消，所以在业务中不适用
            自定义作用域：自定义的协程作用域，不会造成内存泄露

        2.协程调度器：
            Dispatchers.Main:执行的线程是主线程
            Dispatchers.IO：执行的线程是IO线程
            Dispatchers.Default：执行的线程是CPU线程
            Dispatchers.Unconfined：非限制的调度器，指定的线程会随挂起函数发生变化

        3.构建器：
            lauch的作用是启动一个新协程，它返回一个Job对象，我们可以通过job.cancel取消这个协程
                val scope = MainScope()
                scope.launch(Dispatchers.Unconfined) {
                    val one = getResult(20)
                    val two = getResult(40)
                    mNumTv.text = (one + two).toString()
                }
                private suspend fun getResult(num: Int): Int {
                    delay(5000)
                    return num * num
                }

            除了lauch还有一个方法是asnc，他的作用是创建一个协程后返回一个Deferred<T>对象，我们可以通过Deferred.wait去获取返回的值
                scope.launch(Dispatchers.Unconfined) {
                    val one = async { getResult(20) }
                    val two = async { getResult(40) }
                    mNumTv.text = (one.await() + two.await()).toString()
                }
            除了上面的并发执行任务，async还可以对它的start入参设置成懒加载，这样系统只有在调用它时才会为它分配资源
                val one = async(start=CoroutineStart.LAZY){getResult(20)}

        4.suspend
            修饰函数的关键字，意思是当前函数是可以挂起的，起到提醒的作用，当我们函数没有必要挂起的时候，编译器会提醒Redudant suspend modifier
            挂起函数使用场景
                (1)耗时操作：使用withContext切换到指定IO线程进行网络或者数据请求
                    private suspend fun getResult(num:Int):Int{
                        return withContext(Dispatcher.IO){
                            num*num
                        }
                    }
                (2)延迟操作:使用delay方法去等待某个事件
                    private suspend fun getResult(num:Int):Int{
                        delay(5000)
                        return num*num
                    }
        5.协程结合Android jetpack
            lifecycleScope.lauch{
                whenResumed{//代码}
            }
            viewModelScope.lauch{//代码}

三、流Flow
    Flow的使用和Rxjava非常相似
    1.基础
        lifecycleScope.lauch{
            createFlow()
                .collect{num->

                }
        }
        Flow中的数据源Flow<T>相当于Rxjava的Observable<T>
        Flow中的订阅collect相当于Rxjava的subscribe

