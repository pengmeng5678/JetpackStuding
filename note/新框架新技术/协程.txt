协程：
    https://juejin.cn/post/6854573211418361864
协程、LiveData、Flow:
    https://mp.weixin.qq.com/s/p5H51RC6QfyyoAcQ1aGRLg
一、基本介绍
    定义：轻量级的线程
    优点：
        1.可以通过阻塞的方式写出非阻塞的代码，解决常见的回调地狱问题
        2.很容易离开主线程
        3.样板代码最少：活用了Kotlin语言的能力，包括suspend方法
        4.结构并发性：当一个操作不再需要被执行时，协程会自动取消它

二、基本使用
    GlobalScope.launch(Dispatchers.IO){//}
    上面代码包含三个部分，Global、Dispatcher、launch，分别表示：
        1.协程作用域：
            三种作用域类型
            runblocking:顶层函数，它会阻塞当前线程来等待，所以在业务中不适用
            GlobalScope:全局协程作用域，可以在整个应用的生命周期中操作，且不能取消，所以在业务中不适用
            自定义作用域：自定义的协程作用域，不会造成内存泄露
                lifecycleScope
                viewModelScope
        2.协程调度器：
            Dispatchers.Main:执行的线程是主线程
            Dispatchers.IO：执行的线程是IO线程
            Dispatchers.Default：执行的线程是CPU线程
            Dispatchers.Unconfined：非限制的调度器，指定的线程会随挂起函数发生变化

        3.构建器：
            lauch的作用是启动一个新协程，它返回一个Job对象，我们可以通过job.cancel取消这个协程
                val scope = MainScope()
                scope.launch(Dispatchers.Unconfined) {
                    val one = getResult(20)
                    val two = getResult(40)
                    mNumTv.text = (one + two).toString()
                }
                private suspend fun getResult(num: Int): Int {
                    delay(5000)
                    return num * num
                }

            除了lauch还有一个方法是asnc，他的作用是创建一个协程后返回一个Deferred<T>对象，我们可以通过Deferred.wait去获取返回的值
                scope.launch(Dispatchers.Unconfined) {
                    val one = async { getResult(20) }
                    val two = async { getResult(40) }
                    mNumTv.text = (one.await() + two.await()).toString()
                }
            除了上面的并发执行任务，async还可以对它的start入参设置成懒加载，这样系统只有在调用它时才会为它分配资源
                val one = async(start=CoroutineStart.LAZY){getResult(20)}

        4.suspend
            修饰函数的关键字，意思是当前函数是可以挂起的，起到提醒的作用，当我们函数没有必要挂起的时候，编译器会提醒Redudant suspend modifier
            挂起函数使用场景
                (1)耗时操作：使用withContext切换到指定IO线程进行网络或者数据请求
                    private suspend fun getResult(num:Int):Int{
                        return withContext(Dispatcher.IO){
                            num*num
                        }
                    }
                (2)延迟操作:使用delay方法去等待某个事件
                    private suspend fun getResult(num:Int):Int{
                        delay(5000)
                        return num*num
                    }
        5.协程的取消
            绝大部分情况，协程的取消是自动的，即通过协程作用域
            所有 kotlin.coroutines 的 suspend 方法都是可取消的
                suspend fun printPrimes() {
                    while(true) {
                        //delay也是一个suspend方法，每一次delay都会检查协程是否处于有效状态,一旦发现协程被取消，循环的操作也会被取消
                        delay(1000)
                    }
                }
三、流Flow
    Flow的使用和Rxjava非常相似
    1.Flow基础
        特点：
            1.冷流：有点类似Kotlin懒加载，只有当collect方法执行的时候，数据才开始发射
            2.有序:每个数据都是经过 emit、filter 、map和 collect 这一套完整的处理流程后，下个数据才会开始处理，而不是所有的数据都先统一 emit，完了再统一 filter，接着 map，最后再 collect
            3.协作取消：Flow 采用和协程一样的协作取消，也就是说，Flow 的 collect 只能在可取消的挂起函数中挂起的时候取消，否则不能取消。
        基本使用：
            lifecycleScope.lauch{
                createFlow()
                    .collect{num->

                    }
            }
            Flow中的数据源Flow<T>相当于Rxjava的Observable<T>
            Flow中的订阅collect相当于Rxjava的subscribe

        创建Flow对象
            fun createFlow():Flow<Int> = flow{
                for (i in 1..10)
                    emit(i)
            }

            一直调用emit不方便，Flow提供了和Rxjava.just类似的方法
            flowof(vararg elements: T)：帮助可变数组生成 Flow 实例
            扩展函数 .asFlow()：面向数组、列表等集合

        消费数据
            collect方法和Rxjava中的subscribe方法一样，都是用来消费的
            collect方法是一个suspend方法，所以它必须发生在协程或者带有suspend方法里面

    2.Flow线程切换
        协程切换线程
           lifecycleScope.launch {
               // 创建一个协程 Flow<T>
               createFlow()
                   // 将数据发射的操作放到 IO 线程中的协程
                   .flowOn(Dispatchers.IO)
                   .collect { num ->
                       // 具体的消费处理
                       // ...
                   }
               }
           }
        改变数据发射的线程：Flow的flowOn方法类似Rxjava的subscribeOn
        改变数据消费的线程：Flow消费数据的线程在启动协程时就已经通过调度器(Dispatcher)确定好了

    3.Flow异常和完成
        异常捕获
            Flow通过catch捕获异常，Rxjava通过onError捕获异常
                lifecycleScope.launch {
                    flow {
                        //...
                    }.catch {e->

                    }.collect()
                }
        完成
            lifecycleScope.launch {
                createFlow()
                    .onCompletion {
                        // 处理完成操作
                    }
                    .collect {

                    }
            }

    4.操作符对比
        普通操作符：
            map:转换操作符，将A变成B
            take:后面跟Int类型的参数，表示接收多少个emit的值
            filter过滤操作符
        特殊操作符(发送数据是并发的)
            buffer:数据发射并发,collect不并发

    5.Flow结合Retrofit
        https://mp.weixin.qq.com/s/pxNSXRkS0zIBoR0L02O1vQ

四、通道
    Channel是一个面向多协程之间数据传输的BlockQueue，使用如下
        lifecycleScope.launch {
            // 1. 生成一个 Channel
            val channel = Channel<Int>()

            // 2. Channel 发送数据
            launch {
                for(i in 1..5){
                    delay(200)
                    channel.send(i * i)
                }
                channel.close()
            }

            // 3. Channel 接收数据
            launch {
                for( y in channel)
                    Log.e(TAG, "get $y")
            }
        }
    1.创建Channel
        方式一：直接创建Channel对象
        方式二：通过produce函数
            lifecycleScope.launch {
                // 1. 生成一个 Channel
                val channel = produce<Int> {
                    for(i in 1..5){
                        delay(200)
                        send(i * i)
                    }
                    close()
                }

                // 2. 接收数据
                // ... 省略 跟之前代码一致
            }
    2.发送数据
        Channel#send()方法，当数据发送完毕后，可以用Channel#close方法表明通道已经结束数据的发送
    3.接收数据
        获取一次数据
            Channel#receive()
        获取指定次数的数据
            repeate(4){
                Log.e(TAG, "get ${channel.receive()}")
            }
        获取未知数量的数据，需要迭代Channel
            for( y in channel)
                Log.e(TAG, "get $y")

五、多协程数据处理
    多协程处理并发数据的时候，原子性同样也得不到保证，协程中出了一种叫 Mutex 的锁，区别是它的 lock 操作是挂起的，非阻塞的

六、协程与jetpack结合使用
    一、ViewModel模式：
    1.在ViewModel中启动协程
        class MyViewModel : ViewModel {
            private val _result = MutableLiveData<String>()
            val result: LiveData<String> = _result

            init {
                viewModelScope.launch {
                    val computationResult = doComputation()
                    _result.value = computationResult
                  }
              }
        }
        以上代码做了三件事
            1、准备一个 ViewModel 私有的 MutableLiveData (MLD)
            2、暴露一个不可变的 LiveData
            3、启动协程，然后将其操作结果赋给 MLD

        LiveData的协程构造方法：在lifecycle2.2.0,同样的操作可以用更精简的方法实现
            class MyViewModel{
                val result = liveData{
                    emit(doComputation)
                }
            }

    2.协程与LiveData结合使用
        比如当用户在 UI 中选中一些元素，然后将这些选中的内容显示出来。
        一个常见的做法是，把被选中的项目的 ID 保存在一个 MutableLiveData 里，
        然后运行 switchMap。现在在 switchMap 里，您也可以使用协程构造方法

        private val itemId = MutableLiveData<String>()
        val result = itemId.switchMap {
            liveData { emit(fetchItem(it)) }
        }

        使用emitSource方法从另一个LiveData获取更新的结果
            liveData(Dispatchers.IO) {
                emit(LOADING_STRING)
                emitSource(dataSource.fetchWeather())
            }

    3.one-shot操作获取单一数据
        数据分层：View -> ViewModel -> Repository -> DataSource

        通过LiveData连接View和ViewModel,然后使用LiveData协程构造方法打通livedata和协程，然后respository和DataSource就是调用suspend方法
            class MyViewModel{
                val result = liveData{
                    emit(respository.fetchData)
                }
            }
    4.observers操作监听多个数据(如当前天气显示)
        方式一：将ViewModel以外(即respository)也使用LiveData
            val currentWeather: LiveData<String> =
                dataSource.fetchWeather()

        方式二：respository和DataSource发射Flow数据,并使用LiveData协程构造函数
            val currentWeatherFlow:LiveData<String> = liveData{
                dataSource.fetWeatherFlow().collect{
                    emit(it)
                }
            }
            更简单的写法
                val currentWeatherFlow: LiveData<String> =
                    dataSource.fetchWeatherFlow().asLiveData()

    5.先发送一个一次性的结果，然后再持续发送多个数值
        1.LiveData方式
            val currentWeather: LiveData<String> = liveData {
                emit(LOADING_STRING)
                emitSource(dataSource.fetchWeather())
            }
        2.Flow方式一
            val currentWeather: LiveData<String> = liveData {
                emit(LOADING_STRING)
                emitSource(dataSource.fetchWeatherFlow().asLiveData)
            }
        3.Flow方式二
            val currentWeather: LiveData<String> =
                dataSource.fetchWeatherFlow()
                    .onStart{emit(LOADING_STRING)}
                    .asLiveData()

    6.接收的数据需要做转换
        1.使用liveData
            使用switchMap，从而通过liveData协程构造方法获得一个LiveData
            而且switchMap方法会在每次数据源LiveData更新时调用，heavyTransformation 函数进行数据转换，并发送其结果给 liveData 协程构造方法
            val currentWeatherLiveData: LiveData<String> =
                dataSource.fetchWeather().switchMap {
                    liveData { emit(heavyTransformation(it)) }
            }

        2.使用Flow
            直接从dataSource获取数据，然后调用Flow的map方法，再转换为liveData
                val currentWeatherFlow:LiveData<String> =
                    dataSource.fetchWeatherFlow()
                        .map{heavyTransformation(it)}
                        .asLiveData()

     7.repository模式：一般用于进行复杂的数据转换和处理，现在通过 Flow 就可以完成各种复杂的操作
            val currentWeatherFlow: Flow<String> =
                dataSource.fetchWeatherFlow()
                    .map { ... }
                    .filter { ... }
                    .dropWhile { ... }
                    .combine { ... }
                    .flowOn(Dispatchers.IO)
                    .onCompletion { ... }

六、协程与结合不同类型的数据源协作
    Retrofit 从 2.6.0 开始支持 suspend 方法，Room 从 2.1.0 开始支持 suspend 方法。
    1.单次操作
        如果使用Retrofit从远程数据源获取数值，直接将方法标记为suspend方法即可
            suspend fun doOneShot(param:String):String =
                retrofitClient.doSomething(param)

    2.回调机制
        如果数据源不支持协程，且使用回调机制，可以使用suspendCancellabeCoroutine协程构造方法
        这个方法是协程和回调之间的适配器，会在内部提供一个 continuation 供开发者使用
            suspend fun doOneShot(param: String) : Result<String> =
                suspendCancellableCoroutine { continuation ->
                    api.addOnCompleteListener { result ->
                        continuation.resume(result)
                    }.addOnFailureListener { error ->
                        continuation.resumeWithException(error)
                    }
              }

    3.监听操作
        数据源持续发送数值，如每隔两秒发送一个天气值
            override fun fetchWeatherFlow():Flow<String> = Flow{
                counter++
                delay(200)
                emit(weatherString)
            }

        如果使用的是不支持Flow而是使用的回调的代码库，可以使用callbackFlow
            fun flowFrom(api:CallbackBaseApi):Flow<T> = callbackFlow{
                val callback = object :Callback{
                    override fun onNextValue(value: T) {
                        //通过offer方法将数据源发送给Flow
                        offer(value)
                    }
                    override fun onApiError(cause: Throwable) {
                        close(cause)
                    }
                    override fun onCompleted() = close()
                }
                api.register(callback)
                //如果API不会再有更新，则使用awaitClose彻底关闭这条数据通道
                awaitClose{api.unregister(callback)}
            }

七、协程与Room协作
    https://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg==&mid=2652058452&idx=2&sn=2ba868c5bc443d2ad185fed8c39ade41&chksm=808c9311b7fb1a07ba59ef3cf21c7ee137eeea20ec2542529a007cb97b0daf56145fe9cb5c31&scene=178&cur_album_id=1355322955810799617#rd
    Room2.1版本支持对协程的支持
    Room2.2我们通过 Flow 为读操作加入了可观察性，当数据库中的数据有变化时它可以使您收到通知
