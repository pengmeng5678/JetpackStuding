一.泛型
    1.作用与定义
        定义：JDK1.5之后推出泛型,泛型是指将类型作为参数输入，使得可以使用的类型多样化，从而实现解耦
        作用：
            1.可以写出更加灵活通用的代码，解耦
            2.将安全性检查由运行期提前到编译期，解决类型容器安全问题
        原理：
            使用擦除的方法实现泛型：
                擦除是指一定程度上无视类型参数T，直接从T所在的类开始向上T的父类去擦除
                如调用泛型方法，传入类型参数T进入方法内部，Java进行内部擦除，直接把T当做Object类处理，而不是传进来的T
                即有泛型的任何类和方法内部，他都不知道自己的泛型参数，擦除和转型都是在边界上发生
                即传进去的参数在进入类和方法时被擦除掉，但传出来时又被转成了我们设置的T
    2.通配符与嵌套
    3.泛型上下边界
        https://blog.csdn.net/hhllf61/article/details/108443398?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1.pc_relevant_default&spm=1001.2101.3001.4242.2&utm_relevant_index=4
        1) 常用的 T，E，K，V等泛型字母为有类型，类型参数赋予具体的值

        2) 无界通配符?未知类型  类型参数赋予不确定值，任意类型
            ?是通配符（占位符），可以表示任意一个，T只是一种替代，只能表示其中一个
            假设有A，B，C三个类
            <?>可以是A，B，C任意一个,每一个<?>之间没有关联
            <T>如果确定了是A那之后的都是A，每一个<T>代表的是相同的
        3) 上界通配符 < ? extends E>
            能够接收E类或者E类的子类,上边界通配符直接使用add()方法受限，但是可以用来获取各种数据类型的数据
        4) 下界通配符 < ? super E>
            下边界通配符使用get()方法受限（不使用强转），但是可以添加特定类型的值

    4.Rxjava深入理解泛型
        泛型分为:
        1.自定义泛型接口 interface Observer<T>
        2.泛型类 class ImplObserver<T> implements Observer<T>
        3.泛型方法 <T> Observer<T> call(T t)
        说一下泛型的作用域:
            如果将泛型声明放在泛型接口,泛型类上,则该泛型在该类中就是确定的了,如果将泛型声
        明放在了泛型方法上,则该泛型只在该方法中有效,如果泛型方法上声明的泛型类型和类或
        接口中声明的泛型一致,则会在该方法中隐藏类或接口上的泛型

        //创建被观察者
        public class ImplObservable<T> implements Observable<T>{
            T t;
            private ImplObservable(T t){
                this.t = t;
            }
            public static <T> Observable<T> create(T t) {
                return new ImplObservable<T>(t);
            }
        }
        Observable<Student> create = ImplObservable.create(new Student());
        //转换方法T转R
        public interface Func1<T,R> {
            R call(T t);
        }
        创建map方法
        public <R> Observable<R> map(Func1<T, R> fun1) {
            Observable<R> ob = ImplObservable.create(fun1.call(t));
            return ob;
        }
        //
        public Observable<T> next(Action<T> action) {
            action.callAction(t);
            return this;
        }

二、注解
    1.注解
        定义：ANNOTATIONS,注解的声明使用@interface关键字

        作用：
            1.提供信息给编译器，编译期可以通过注解探测错误和警告信息
            2.编译阶段：注解可以用于生成代码、HTML文档等
            3.运行阶段：可以通过反射获取注解和相关的类，做逻辑判断
                可以通过 Class 对象的 isAnnotationPresent()方法判断它是否应用了
                某个注解，再通过 getAnnotation()方法获取 Annotation 对象

        声明：
            java中所有的注解，默认实现Annotation接口
                package java.lang.annotation;
                public interface Anotation{
                    boolean equals(Object obj);
                    int hashCode();
                    String toString();
                    Class<? extends Anotation> annotationType();
                }

            与声明一个Class不同的是，注解的声明使用@interface关键字：
                @interface Source{
                    public String URL();
                    public String mail();
                }
                //使用方式
                @Source(URL = "http://coders.com/"

    2.元注解
        定义：用于定义注解的注解
        作用：定义注解的作用范围，使用在什么元素上
        种类：四种
            @Target:用于修饰哪些程序元素，以限制可以应用注解的java元素类型。目标注解指定以下元素类型之一作为其值：
                ElementType.ANNOTATION_TYPE 可以应用于注解类型
                ElementType.CONSTRUCTURE 可以应用于构造函数
                ElementType.FIELD 可以应用于字段或者属性
                ElementType.METHOD 可以应用于方法级注解
                ElementType.TYPE 可以应用于类的任何元素
                ElementType.PARAMETER 可以应用于参数的注解(可以替换枚举节省内存)

            @Retention:保留的范围(存活的时间)，默认值为CLASS,可选值有三种：
                RetentionPolicy.SOURCE,只在源码中可用；
                RetentionPolicy.CLASS，会保留在class文件中，但是会被虚拟机忽略(即无法在运行期反射获取注解),在源码和字节码中可用；
                RetentionPolicy.RUNTIME,标记的注解由JVM保留，在源码、字节码、运行时都可以使用它

            @Inherited:是否可以被继承，默认为false
            @Documented:是否会保存到Javadoc文档中

        应用场景：
            根据@Retation元注解的保留级别不一样，注解作用于源码、字节码、运行时三种场景，具体的应用技术如下：
                1.源码场景：应用技术：APT,在编译期能够获取注解与注解声明的类，包括类中所有成员信息，一般用于生成额外的辅助类
                2.字节码场景，应用技术：字节码增强/AspectJ/热修复，在编译出Class后，通过修改Class数据以实现修改代码逻辑目的。对于是否需要修改的区分或者修改为不同逻辑的判断可以使用注解。
                3.运行时，应用技术：反射，在程序运行过程中，通过反射技术动态获取注解与其元素，从而完成不同的逻辑判定

    3.自定义注解
        @Retention(RetentionPolicy.RUNTIME)     //在源码、字节码、运行时都可以使用它
        @Target(ElementType.FIELD)              //只能在属性上标记该注解
        public @interface TestAnnotation {
            String value();
            String[] value2() default "value2";
        }

    4.APT
        定义：Anotation Processing Tool，编译时注解处理器，Javac的一个工具，核心类是AbstractProcessor类
        作用：APT可以用来在编译时扫描和处理注解，
             通过 APT 可以获取到注解和被注解对象的相关信息，在拿到这些信息后我们可以根据需求来自动的生成一些代码，省去了手动编写
        使用场景：ButterKnife,EventBus,Dagger2,ARouter等开源框架
        如何构建APT项目：
            1.至少需要两个Java Library模块组成：
                一个Annotation模块
                一个Compiler模块(Compiler模块依赖Annotation模块),
                    且App模块和其他业务模块都需要依赖 Annotation 模块
                    同时需要通过 annotationProcessor 依赖 Compiler 模块
                    app 模块的 gradle 中依赖关系如下
                        implementation project(':annotation')
                        annotationProcessor project(':factory-compiler')

    5.插桩
        定义：将一段代码插入或者替换原本的代码
        作用:利用注解标记需要插桩的方法，结合编译后的字节码帮助我们自动插入，这种AOP思想让我们只需要关注插桩代码本身
        字节码插桩：在我们编写的源码编译成字节码(class)后，在Android下生成dex之前修改Class文件，修改或者增强原有代码逻辑的操作
        应用场景：QQ空间《热修复解决方案》中利用 Javaassist 库实现向类的构造函数中插入一段代码解决 CLASS_ISPREVERIFIED 问题
        字节码操作框架：ASM,Javaassist。(根据Class字节码的规则格式，通过字节码操作框架对字节码进行修改)
        AS插件：ASM Bytecode Viewer

三、反射
        https://www.jianshu.com/p/f67182a482eb
        定义：在运行状态中，对于任意一个类，都能获取类的所有属性和方法，对于任意一个对象，都可以调用对象的属性和方法
        这种动态获取信息及动态调用对象的机制成为java语言的反射机制
        实现步骤：
            public class Person {
                private String name;
                private int age;
                private String msg="hello wrold";
                public Person() {}
                public void fun(String name,int age) {
                    System.out.println("我叫"+name+",今年"+age+"岁");
              }
            }

            1.获取类的Class对象实例
            Class c = Class.forName("com.tengj.reflect.Person");

            2.根据Class对象实例，通过newIntance方法获取对象实例
            Object o = c.newInstance();

            3.根据class对象获取你要操作对象中的构造方法(Constructor)、普通方法(Method)、属性字段(Field)
            Method method = c.getMethod("fun", String.class, int.class);

            4.通过invoke调用对象的方法
            method.invoke(o, "tengj", 10);

        如果操作是private类型，
        反射是可以修改final变量的，但是如果是基本数据类型或者String类型的时候，无法通过对象获取修改后的值，因为JVM对其进行了内联优化

        获取方法getMethods、getDeclaredMethods
        获取属性getFields、getDeclaredMethods

        包含Declared表示可以获取到私有的属性和方法，
        如果要实际调用私有方法和属性，还要提前设置允许暴力操作，setAccessible(true)