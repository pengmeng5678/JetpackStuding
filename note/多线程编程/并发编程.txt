
4.Java内存模型和Java内存区域
    具体说明见E:\AndroidProject\Studing\AndroidStudingProject\note\Java虚拟机\Java内存模型
    java内存模型(Java Memory Model,JMM)就是一种符合内存模型规范的,屏蔽了各种硬件和操作系统访问差异,
  保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制和规范

    java的多线程之间是通过共享内存进行通信的,而由于采用共享内存进行通信,在通信过程中会存在一系列如可见性、原子性、有序性等问题
  而JMM就是围绕这多线程通信以及与其相关的一系列特性而建立的模型。

    Java内存模型规定了所有的变量都存储在主内存中,每条线程还有自己的工作内存,线程中的保存了该线程中用到的变量的主内存副本拷贝
  线程对变量的操作都要在工作内存中进行, 而不能直接读写主内存；不同的线程也不能直接访问对方工作内存中的变量,
  线程间变量的传递需要自己的工作内存先写入到主内存后再进行数据同步进行。

5.原子性、可见性、有序性简介
    原子性：指一个操作是不可中断的,即使是在多线程环境下,一个操作一旦开始就不会被其他线程影响
    可见性: 指一个线程修改了一个共享变量的值之后,其他线程是否能够马上知道这个修改的值
    有序性: 指在单线程的执行代码,我们总是认为代码的执行是按顺序依次执行的。但对于多线程环境,可能是乱序执行的,因为代码编译成机器指令后可能会出现指令重排现象。
6.生产者和消费者模型
    生产者和消费者模型保证的是当缓冲区满了的时候，生产者不再生产数据；当缓冲区空的时候,消费者不再消费数据;
    实现机制就是：当缓冲区满时,生产者进入等待状态，当缓冲区空时，让消费者进入等待状态；当生产后数据后,唤醒消费者，当消费数据后，唤醒生产者
    三种实现方式:wait和notify,await和signal(Reentrantlock,Reentrantlock.newCondition),BlockQueue(put,take)

7.Java线程死锁


11.CAS
    Compare And Swap

12 countLatch