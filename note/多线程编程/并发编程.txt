1.线程的状态
    初始状态、就绪状态、运行状态、阻塞状态(synchrounized)、等待状态、等待超时状态、死亡状态
2.死锁
    定义：两个或者两个以上的进程在执行过程中，由于竞争资源造成的阻塞的现象，
         在无外力作用时，它们都无法推进下去，此时称系统处于死锁状态或者系统产生了死锁。

    产生死锁的条件
        白话描述
            1.多个操作者(M>=2),争夺多个资源(N>=2),N<=M
            2.争夺资源的顺序不对
            3.拿到资源不放手

        学术描述：
            1.互斥条件：
                指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。
                如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放
            2.请求和保持条件
                指进程已经保持至少一个资源，但又提出了新的资源请求，
                而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
            3.不剥夺
                指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
            4.环路等待
                指在发生死锁时，必然存在一个进程——资源的环形链，
                即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1
                正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源

    如何避免死锁
        让任意一个死锁得条件得不到不满足.
        1.修改锁的顺序，两个线程都先争夺NO13，或者都先争夺NO14
           private static Object No13 = new Object();//第一个锁
           private static Object No14 = new Object();//第二个锁
           Thread1
               synchrounize(NO13){
                    synchrounize(NO14){

                    }
               }
           Thread2
              synchrounize(NO14){
                   synchrounize(NO13){

                   }
              }

        2.拿到资源后主动释放资源，使用ReentrantLock
            https://blog.csdn.net/qq_40551367/article/details/89414446/
            private static Lock No13 = new ReentrantLock();//第一个锁
            private static Lock No14 = new ReentrantLock();//第二个锁
            Thread1
               while(true){
                   try{
                        if(NO13.tryLock()){         //如果获取到锁,返回true;避免像synchrounized进入阻塞状态
                            //业务逻辑
                            try{
                                if(NO14.tryLock()){

                                }
                            }catch(){
                                NO14.unLock()       //主动释放锁资源
                            }
                        }
                    }catch(){
                         NO13.unLock()
                    }

                   Thread.sleep(10)                 //while循环下休眠一段时间,重复获取锁资源，但又不会变成活锁
               }
3.线程安全问题
4.CAS
5.Java内存模型和Java内存区域
    具体说明见E:\AndroidProject\Studing\AndroidStudingProject\note\Java虚拟机\Java内存模型
    java内存模型(Java Memory Model,JMM)就是一种符合内存模型规范的,屏蔽了各种硬件和操作系统访问差异,
  保证了Java程序在各种平台下对内存的访问都能保证效果一致的机制和规范

    java的多线程之间是通过共享内存进行通信的,而由于采用共享内存进行通信,在通信过程中会存在一系列如可见性、原子性、有序性等问题
  而JMM就是围绕这多线程通信以及与其相关的一系列特性而建立的模型。

    Java内存模型规定了所有的变量都存储在主内存中,每条线程还有自己的工作内存,线程中的保存了该线程中用到的变量的主内存副本拷贝
  线程对变量的操作都要在工作内存中进行, 而不能直接读写主内存；不同的线程也不能直接访问对方工作内存中的变量,
  线程间变量的传递需要自己的工作内存先写入到主内存后再进行数据同步进行。

6.原子性、可见性、有序性简介
    原子性：指一个操作是不可中断的,即使是在多线程环境下,一个操作一旦开始就不会被其他线程影响
    可见性: 指一个线程修改了一个共享变量的值之后,其他线程是否能够马上知道这个修改的值
    有序性: 指在单线程的执行代码,我们总是认为代码的执行是按顺序依次执行的。但对于多线程环境,可能是乱序执行的,因为代码编译成机器指令后可能会出现指令重排现象。
7.生产者和消费者模型
    生产者和消费者模型保证的是当缓冲区满了的时候，生产者不再生产数据；当缓冲区空的时候,消费者不再消费数据;
    实现机制就是：当缓冲区满时,生产者进入等待状态，当缓冲区空时，让消费者进入等待状态；当生产后数据后,唤醒消费者，当消费数据后，唤醒生产者
    三种实现方式:wait和notify,await和signal(Reentrantlock,Reentrantlock.newCondition),BlockQueue(put,take)


8.CAS
    Compare And Swap
