https://blog.csdn.net/javazejian/article/details/72772461
https://www.jianshu.com/p/cf57726e77f2
并发编码的两大核心：JMM和happens-before规则。三大性质：原子性、有序性和可见性
1.java内存区域、Java内存模型以及Java对象模型之间的区别
    1.java内存区域
        Java虚拟在运行程序时会把其自动管理的内存划分为方法区、JVM堆、虚拟机栈、程序计数器、本地方法栈这五个区域。每个区域都有其用途及创建和销毁的时机
    其中方法区和堆是所有线程共享的数据区域，而虚拟机栈、程序计数器、本地方法栈是线程私有的区域

        方法区：线程共享内存区域，存放已被虚拟机加载的类信息、常量、静态变量等数据
        JVM堆：线程共享内存区域,主要存放对象实例,几乎所有对象实例都在这里分配内存,这里是垃圾收集器的主要区域，也成GC堆

        程序计数器：线程私有区域,代表当前线程所执行的字节码行号指示器。字节码解释器工作时,通过改变这个计数器的值来选取下一条需要执行的字节码指令
        虚拟机栈：线程私有区域,与线程同时创建,总数与线程关联,代表java方法执行的内存。每个方法执行时都会创建一个栈帧来存储方法的变量表、操作数栈、返回地址等信息
    每个方法从调用开始到结束就对应一个栈帧在虚拟机栈中的入栈和出栈。
        本地方法栈：线程私有区域,这部分主要与虚拟机用到的Native方法相关

    2.java内存模型
        Java Memory Model,简称JMM，本身是一种抽象的概念,它描述的是一组规则和规范，通过这组规范定义了程序中各个变量(实例字段、静态字段)的访问方式
    由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存,用于存储线程私有的数据。而java内存模型中规定所有变量都存储在主内存,
    主内存是共享内存区域,所有线程都可以访问,但线程对变量的操作都必须在主内存中进行,首先要将变量从主内存拷贝到工作内存,然后对变量进行操作后再将变量
    写到主内存中。工作内存中存储着主内存的变量副本拷贝。
        主内存:主要存储Java实例对象，不管实例对象是成员变量还是方法中的本地变量。当然还包括类信息,常量，静态变量
        工作内存:主要存储当前方法的所有本地变量信息

        根据虚拟机规范,对于一个实例对象中的成员方法而言,
            方法中的本地变量时基本数据类型，将直接存储的工作内存的栈帧结构中
            方法中的变量是引用类型，将会存储在功能内存的栈帧中
            对象实例将存储在主内存中(共享数据区域、堆中)
    3.java对象模型

2.JMM存在的必要性
    由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存,用于存储线程私有的数据。线程与主内存的变量操作必须通过工作内存间接进行
 具体过程是将变量从主内存拷贝到各个线程的工作内存，在工作内存对变量进行操作后，再写回到主内存。所以如果存在多个线程操作同一个共享变量时就会存在线程安全问题
 为了解决线程安全问题,JMM就定义了一套规则,来决定当一个线程对共享变量的写入何时对另一个线程是可见的。这组规则就是java内存模型，即JMM

3.Java内存模型的承诺(三大性质)
    原子性：指一个操作是不可中断的,要么全部执行成功,要么全部执行失败。即使是在多线程环境下,一个操作一旦开始就不会被其他线程影响
        如int a=10;是原子操作，而a++;int b=a;a=a+1;都不是原子操作。java内存模型中定义了以下8种原子操作，是不可再分的
        lock锁定、unlocak解锁、read读取、load(载入)、use(使用)、assign赋值、store存储、write操作
        synchronized满足原子性,但volatile不满足原子性

    可见性: 指一个线程修改了一个共享变量的值之后,其他线程是否能够马上知道这个修改的值
        synchronized具有可见性,因为线程释放锁时会将共享变量同步到主内存中,volatile也具有可见性
    有序性: 指在单线程的执行代码,我们总是认为代码的执行是按顺序依次执行的。但对于多线程环境,可能是乱序执行的,因为为了性能优化，编译器和处理器会对指令进行重排序。
        synchronize具备有序性，因为锁在同一个时刻只能有一个线程进行获取，其他线程只能等待,因此synchronize语义要求线程访问共享变量时只能串行执行
        volatile包含禁止指令重排序的语义，具有有序性

4.volatile的语义
    1.保证可见性：保证不同线程对该变量操作内存的可见性，但是不等同于volatile变量并发操作的安全性
        线程写volatile变量的过程
            1.改变线程工作内存中volatile变量副本的值
            2.将改变后的副本的值从工作内存刷新到主内存
        线程读volatile变量的过程
            1.从主内存中读取volatile的最新值拷贝到线程中工作内存
            2.从工作内存中读取volatile变量的副本

        注意：多个线程把更新后的变量值同时刷新到主内存，可能导致不是预期结果，如
            定义volatile int count = 0,2个线程分别执行count++，各执行500次，最终的执行结果小于1000
            因为执行一次count++的结果需要经历如下步骤：
                1.线程从主内存读取到最新的count值
                2.执行引擎把count值加1，并赋值给工作内存
                3.线程工作内存把count值刷新给主内存

                有可能某一个时刻，两个线程执行步骤1时，读取到的值都是100，那两个线程执行count++后，刷新到主内存的值都是101

    2.禁止指令重排序
        举例
        volatile boolean initialized = false ;
        // 下面代码线程 A 中执行读取配置信息，当读取完成后将 initialized 设置为 true 以通知其他线程配置可用
        doSomethingReadConfg();
        initialized = true ;

        如果定义 initialized 变量时没有使用 volatile 修饰，就有可能会由于指令重排序的优化，
        导致线程 A 中最后一句代码 "initialized = true" 在 “doSomethingReadConfg()” 之前被执行

        volatile实现禁止指令重排序的实现原理是通过内存屏障实现的：
        volatile使用场景，一次写入，多处读取

5.synchrounized实现原理和优化项
    使用synchrounized包裹的代码块有如下规则
        1.读数据：当线程进入到该区域读取最新变量信息时，对数据的读取只能从主内存中读取，保证读到的时最新值
        2.写数据：在同步代码块对变量的写操作，在离开同步代码块后，会将工作内存的数据刷新到主内存中，保证更新的数据对其他线程的可见性
    总结
        synchronized具有原子性、可见性、有序性
        volatile具有可见性和有序性
