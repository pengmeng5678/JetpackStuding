https://blog.csdn.net/javazejian/article/details/72772461
https://www.jianshu.com/p/cf57726e77f2
并发编码的两大核心：JMM和happens-before规则。三大性质：原子性、有序性和可见性
1.java内存区域、Java内存模型以及Java对象模型之间的区别
    1.java内存区域
        Java虚拟在运行程序时会把其自动管理的内存划分为方法区、JVM堆、虚拟机栈、程序计数器、本地方法栈这五个区域。每个区域都有其用途及创建和销毁的时机
    其中方法区和堆是所有线程共享的数据区域，而虚拟机栈、程序计数器、本地方法栈是线程私有的区域

        方法区：线程共享内存区域，存放已被虚拟机加载的类信息、常量、静态变量等数据
        JVM堆：线程共享内存区域,主要存放对象实例,几乎所有对象实例都在这里分配内存,这里是垃圾收集器的主要区域，也成GC堆

        程序计数器：线程私有区域,代表当前线程所执行的字节码行号指示器。字节码解释器工作时,通过改变这个计数器的值来选取下一条需要执行的字节码指令
        虚拟机栈：线程私有区域,与线程同时创建,总数与线程关联,代表java方法执行的内存。每个方法执行时都会创建一个栈帧来存储方法的变量表、操作数栈、返回地址等信息
    每个方法从调用开始到结束就对应一个栈帧在虚拟机栈中的入栈和出栈。
        本地方法栈：线程私有区域,这部分主要与虚拟机用到的Native方法相关

    2.java内存模型
        Java Memory Model,简称JMM，本身是一种抽象的概念,它描述的是一组规则和规范，通过这组规范定义了程序中各个变量(实例字段、静态字段)的访问方式
    由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存,用于存储线程私有的数据。而java内存模型中规定所有变量都存储在主内存,
    主内存是共享内存区域,所有线程都可以访问,但线程对变量的操作都必须在主内存中进行,首先要将变量从主内存拷贝到工作内存,然后对变量进行操作后再将变量
    写到主内存中。工作内存中存储着主内存的变量副本拷贝。
        主内存:主要存储Java实例对象，不管实例对象是成员变量还是方法中的本地变量。当然还包括类信息,常量，静态变量
        工作内存:主要存储当前方法的所有本地变量信息

        根据虚拟机规范,对于一个实例对象中的成员方法而言,
            方法中的本地变量时基本数据类型，将直接存储的工作内存的栈帧结构中
            方法中的变量是引用类型，将会存储在功能内存的栈帧中
            对象实例将存储在主内存中(共享数据区域、堆中)
    3.java对象模型

2.JMM存在的必要性
    由于JVM运行程序的实体是线程,而每个线程创建时JVM都会为其创建一个工作内存,用于存储线程私有的数据。线程与主内存的变量操作必须通过工作内存间接进行
 具体过程是将变量从主内存拷贝到各个线程的工作内存，在工作内存对变量进行操作后，再写回到主内存。所以如果存在多个线程操作同一个共享变量时就会存在线程安全问题
 为了解决线程安全问题,JMM就定义了一套规则,来决定当一个线程对共享变量的写入何时对另一个线程是可见的。这组规则就是java内存模型，即JMM

3.Java内存模型的承诺(三大性质)
    原子性：指一个操作是不可中断的,要么全部执行成功,要么全部执行失败。即使是在多线程环境下,一个操作一旦开始就不会被其他线程影响
        如int a=10;是原子操作，而a++;int b=a;a=a+1;都不是原子操作。java内存模型中定义了以下8种原子操作，是不可再分的
        lock锁定、unlocak解锁、read读取、load(载入)、use(使用)、assign赋值、store存储、write操作
        synchronized满足原子性,但volatile不满足原子性

    可见性: 指一个线程修改了一个共享变量的值之后,其他线程是否能够马上知道这个修改的值
        synchronized具有可见性,因为线程释放锁时会将共享变量同步到主内存中,volatile也具有可见性
    有序性: 指在单线程的执行代码,我们总是认为代码的执行是按顺序依次执行的。但对于多线程环境,可能是乱序执行的,因为为了性能优化，编译器和处理器会对指令进行重排序。
        synchronize具备有序性，因为锁在同一个时刻只能有一个线程进行获取，其他线程只能等待,因此synchronize语义要求线程访问共享变量时只能串行执行
        volatile包含禁止指令重排序的语义，具有有序性

4.synchrounized实现原理和优化项

    总结
        synchronized具有原子性、可见性、有序性
        volatile具有可见性和有序性
